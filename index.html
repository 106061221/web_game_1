<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>雙搖桿射擊遊戲 - 最終微調版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: Arial; touch-action: none; }
        canvas { display: block; background: #000; border: 5px solid #333; box-sizing: border-box; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div>武器編號: <span id="weapon-id">1</span></div>
        <div style="margin-top:5px; font-size: 12px; color: #aaa;">左手連點兩下：換武器<br>移動死區：已加大</div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const weaponText = document.getElementById('weapon-id');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// 遊戲狀態
const player = { x: canvas.width/2, y: canvas.height/2, size: 20, speed: 2.5, color: '#00ccff' }; // 速度調慢
const crosshair = { x: canvas.width/2, y: canvas.height/2, size: 10, color: '#ff0000' };
let bullets = [];
let weaponIndex = 0; 
const deadzone = 40; // 不反應位移量加大

// 搖桿與點擊狀態
let leftJoystick = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };
let rightJoystick = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };
let lastLeftTouchTime = 0; // 用於偵測連點

canvas.addEventListener('touchstart', (e) => {
    const now = Date.now();
    for (let touch of e.changedTouches) {
        if (touch.clientX < canvas.width / 2) {
            // 左半邊處理
            leftJoystick.active = true;
            leftJoystick.startX = leftJoystick.currX = touch.clientX;
            leftJoystick.startY = leftJoystick.currY = touch.clientY;
            
            // 偵測連點兩下 (300ms 內)
            if (now - lastLeftTouchTime < 300) {
                switchWeapon();
            }
            lastLeftTouchTime = now;
        } else {
            // 右半邊處理
            rightJoystick.active = true;
            rightJoystick.startX = rightJoystick.currX = touch.clientX;
            rightJoystick.startY = rightJoystick.currY = touch.clientY;
        }
    }
});

canvas.addEventListener('touchmove', (e) => {
    for (let touch of e.changedTouches) {
        if (leftJoystick.active && touch.clientX < canvas.width/2) {
            leftJoystick.currX = touch.clientX;
            leftJoystick.currY = touch.clientY;
        }
        if (rightJoystick.active && touch.clientX >= canvas.width/2) {
            rightJoystick.currX = touch.clientX;
            rightJoystick.currY = touch.clientY;
        }
    }
});

canvas.addEventListener('touchend', (e) => {
    for (let touch of e.changedTouches) {
        if (touch.clientX < canvas.width/2) leftJoystick.active = false;
        else rightJoystick.active = false;
    }
});

function switchWeapon() {
    weaponIndex = (weaponIndex + 1) % 3;
    weaponText.innerText = weaponIndex + 1;
}

function fire() {
    const dx = crosshair.x - player.x;
    const dy = crosshair.y - player.y;
    const angle = Math.atan2(dy, dx);

    if (weaponIndex === 0) {
        createBullet(angle);
    } else if (weaponIndex === 1) {
        createBullet(angle - 0.2);
        createBullet(angle);
        createBullet(angle + 0.2);
    } else if (weaponIndex === 2) {
        createBullet(angle, 12);
        createBullet(angle, -12);
    }
}

function createBullet(angle, offset = 0) {
    bullets.push({
        x: player.x + Math.cos(angle + Math.PI/2) * offset,
        y: player.y + Math.sin(angle + Math.PI/2) * offset,
        vx: Math.cos(angle) * 12,
        vy: Math.sin(angle) * 12
    });
}

let frameCount = 0;
function update() {
    // 1. 移動玩家 (左搖桿 + 加大死區)
    if (leftJoystick.active) {
        const dx = leftJoystick.currX - leftJoystick.startX;
        const dy = leftJoystick.currY - leftJoystick.startY;
        const dist = Math.hypot(dx, dy);
        
        if (dist > deadzone) {
            // 從死區邊緣開始計算移動量，讓動作更平滑
            const moveDist = dist - deadzone;
            player.x += (dx / dist) * player.speed;
            player.y += (dy / dist) * player.speed;
        }
    }

    // 2. 移動準星 (右搖桿)
    if (rightJoystick.active) {
        const dx = rightJoystick.currX - rightJoystick.startX;
        const dy = rightJoystick.currY - rightJoystick.startY;
        const dist = Math.hypot(dx, dy);
        if (dist > 5) {
            crosshair.x = player.x + (dx / dist) * 180;
            crosshair.y = player.y + (dy / dist) * 180;
            if (frameCount % 10 === 0) fire(); 
        }
    } else {
        crosshair.x = player.x;
        crosshair.y = player.y;
    }

    // 邊界限制
    player.x = Math.max(30, Math.min(canvas.width - 30, player.x));
    player.y = Math.max(30, Math.min(canvas.height - 30, player.y));

    // 更新子彈
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx; b.y += b.vy;
        if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
            bullets.splice(i, 1);
        }
    }

    frameCount++;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 畫準星
    if (rightJoystick.active) {
        ctx.strokeStyle = "rgba(255, 0, 0, 0.8)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(crosshair.x, crosshair.y, 12, 0, Math.PI*2);
        ctx.stroke();
        // 畫準星準心
        ctx.beginPath();
        ctx.moveTo(crosshair.x - 5, crosshair.y); ctx.lineTo(crosshair.x + 5, crosshair.y);
        ctx.moveTo(crosshair.x, crosshair.y - 5); ctx.lineTo(crosshair.x, crosshair.y + 5);
        ctx.stroke();
    }

    // 畫玩家
    ctx.fillStyle = player.color;
    ctx.shadowBlur = 10;
    ctx.shadowColor = player.color;
    ctx.fillRect(player.x - 15, player.y - 15, 30, 30);
    ctx.shadowBlur = 0;

    // 畫子彈
    ctx.fillStyle = '#fff';
    bullets.forEach(b => ctx.fillRect(b.x - 3, b.y - 3, 6, 6));

    // 畫搖桿視覺 (死區視覺提示)
    if (leftJoystick.active) {
        drawJoystick(leftJoystick, "#00ccff");
        // 額外畫出死區範圍
        ctx.beginPath();
        ctx.arc(leftJoystick.startX, leftJoystick.startY, deadzone, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.05)";
        ctx.stroke();
    }
    if (rightJoystick.active) drawJoystick(rightJoystick, "#ff0000");

    update();
    requestAnimationFrame(draw);
}

function drawJoystick(joy, color) {
    ctx.beginPath();
    ctx.arc(joy.startX, joy.startY, 50, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(joy.currX, joy.currY, 25, 0, Math.PI*2);
    ctx.fillStyle = color + "44";
    ctx.fill();
    ctx.strokeStyle = color;
    ctx.stroke();
}

draw();
</script>
</body>
</html>
