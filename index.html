<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <title>生存射擊 - 橫向 補包更新版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui-left { position: absolute; top: 20px; left: 30px; color: #fff; pointer-events: none; z-index: 10; }
        #ui-right { position: absolute; top: 20px; right: 30px; text-align: right; color: #fff; pointer-events: none; z-index: 10; }
        .weapon-tag { font-weight: bold; font-size: 22px; color: #00ffcc; }
        #hp-bar { font-size: 20px; color: #ff5555; margin-top: 5px; font-weight: bold; }
        .stat-label { font-size: 16px; color: #ffd700; }
        #overload-info { color: #ff3300; font-weight: bold; font-size: 14px; visibility: hidden; }
        #status-bar { 
            position: absolute; top: 25px; left: 50%; transform: translateX(-50%); 
            color: #ff3300; font-size: 22px; font-weight: bold; pointer-events: none; 
            text-align: center; white-space: pre-wrap; line-height: 1.2;
            text-shadow: 2px 2px 4px #000;
        }
        #weapon-btn {
            position: absolute; right: 40px; bottom: 220px; width: 75px; height: 75px;
            background: rgba(255, 255, 255, 0.1); border: 2px solid #00ffcc;
            border-radius: 50%; color: #00ffcc; display: flex; align-items: center;
            justify-content: center; font-weight: bold; font-size: 14px; z-index: 20;
            backdrop-filter: blur(3px); -webkit-user-select: none;
        }
        #tp-btn {
            position: absolute; right: 130px; bottom: 175px; width: 75px; height: 75px;
            background: rgba(0, 255, 0, 0.1); border: 2px solid #00ff00;
            border-radius: 50%; color: #00ff00; display: flex; align-items: center;
            justify-content: center; font-weight: bold; font-size: 14px; z-index: 20;
            backdrop-filter: blur(3px); -webkit-user-select: none;
            touch-action: none; overflow: hidden;
        }
        #tp-cd-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); pointer-events: none; transform: scaleY(0); transform-origin: bottom; }
        
        @media screen and (orientation: portrait) { #landscape-hint { display: flex; } }
        #landscape-hint { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; color: #fff; z-index: 100; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
    </style>
</head>
<body>
    <div id="landscape-hint"><h2>請旋轉手機至橫向</h2><p>並關閉直排鎖定</p></div>
    <div id="ui-left">
        <div id="hp-bar">HP: <span id="hp-val">30</span></div>
        <div id="overload-info">超載攻速: +<span id="speed-bonus">0</span>%</div>
    </div>
    <div id="status-bar"></div>
    <div id="ui-right">
        <div class="weapon-tag">武器: <span id="weapon-id">1</span></div>
        <div class="stat-label">SCORE: <span id="score-val">0</span></div>
        <div class="stat-label">LV: <span id="level-val">0</span></div>
    </div>
    <div id="weapon-btn">換武器</div>
    <div id="tp-btn">瞬移<div id="tp-cd-overlay"></div></div>
    <canvas id="gameCanvas"></canvas>

<script>
const BASE_FIRE_INTERVAL = 10; 
const WEAPON_CONFIG = {
    1: { id: 1, intervalMult: 1.0, speed: 15, damage: 1.0, color: '#fff' },
    2: { id: 2, intervalMult: 15.0, speed: 15, damage: 1.0, color: '#ffcc00' },
    3: { id: 3, intervalMult: 2.2, speed: 15, damage: 1.0, color: '#00ccff', 
         overloadTriggerTime: 0.6, overloadIncrement: 0.1, ultimateTriggerTime: 3.6, lockoutDuration: 2 }
};
Object.values(WEAPON_CONFIG).forEach(wp => wp.fireInterval = wp.intervalMult * BASE_FIRE_INTERVAL);

const ENEMY_CONFIG = {
    spawnRateBase: 70, 
    1: { id: 1, speed: 0.2, hpBase: 2, size: 15, color: '#888888', shootInterval: 0, weight: 68.5, score: 100, dropRate: 0 }, 
    2: { id: 2, speed: 0.2, hpBase: 4, size: 18, color: '#ff4444', shootInterval: 4, bulletSpeed: 0.6, weight: 15, score: 100, dropRate: 0 }, 
    3: { id: 3, speed: 0.2, hpBase: 4, size: 18, color: '#aa00ff', shootInterval: 13, bulletSpeed: 0.6, weight: 15, score: 100, dropRate: 0 },
    4: { id: 4, speed: 0.2, hpBase: 40, size: 25, color: '#FFD700', shootInterval: 10, bulletSpeed: 0.6, weight: 1.5, score: 500, dropRate: 1 } 
};

const BOSS_CONFIG = {
    101: { 
        id: 101, hpBase: 200, size: 50, color: '#8B0000', score: 5000, triggerScore: 100,
        behavior: {
            targetY: 120,          
            entrySpeed: 1.5,       
            swingRange: 0.3,       
            swingSpeed: 0.01,      
            shootDelay: 1000,      
            bulletSpeed: 1.2       
        }
    }
};

const DIFFICULTY_CONFIG = { threshold: 1000, hpIncrease: 0.05, speedIncrease: 0.05, spawnIncrease: 0.01 };
const PLAYER_SPEED = 1.5; 
const INVULNERABLE_TIME = 250; 
const HIT_FLASH_DURATION = 20; 

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
function handleResize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', handleResize);
handleResize();

let boss = null, isTransitioning = false, b101Triggered = false;
let player = { x: canvas.width/2, y: canvas.height/2, hp: 30, maxHp: 30, size: 17, lastHurtTime: 0 };
let bullets = [], enemyBullets = [], enemies = [], drops = [];
let currentWp = WEAPON_CONFIG[1];
let fireTimer = 0, spawnTimer = 0, score = 0, difficultyLevel = 0, lastAngle = 0;
let wp3IdleStartTime = Date.now(), speedMultiplier = 1.0, overloadFrames = 0, isLocked = false, idleTriggered = false;
let joyL = { active: false, x1: 0, y1: 0, x2: 0, y2: 0, id: -1 };
let joyR = { active: false, x1: 0, y1: 0, x2: 0, y2: 0, id: -1 };
let joyT = { active: false, x1: 0, y1: 0, x2: 0, y2: 0, id: -1 };
let tpTarget = { x: 0, y: 0 }, tpCooldown = 0;
const TP_COOLDOWN_TIME = 3000;

function updateDifficulty() {
    let newLevel = Math.floor(score / DIFFICULTY_CONFIG.threshold);
    if (newLevel > difficultyLevel) {
        difficultyLevel = newLevel;
        document.getElementById('level-val').innerText = difficultyLevel;
    }
}

function triggerBossTransition(id) {
    isTransitioning = true;
    enemies = [];
    enemyBullets = [];
    drops.push({x: canvas.width / 2, y: canvas.height / 2, heal: 10});
    
    let countdown = 5;
    const bar = document.getElementById('status-bar');
    bar.innerText = "WARNING\nBOSS IN " + countdown;
    
    const timer = setInterval(() => {
        countdown--;
        if(countdown > 0) {
            bar.innerText = "WARNING\nBOSS IN " + countdown;
        } else {
            clearInterval(timer);
            bar.innerText = "";
            const cfg = BOSS_CONFIG[id];
            const scaledHp = cfg.hpBase * (1 + difficultyLevel * DIFFICULTY_CONFIG.hpIncrease);
            boss = {
                ...cfg,
                hp: scaledHp,
                maxHp: scaledHp,
                x: canvas.width / 2,
                y: -100,
                lastHitTime: 0,
                angle: 0,
                lastShootTime: 0
            };
            isTransitioning = false;
        }
    }, 1000);
}

function switchWp() {
    let nextId = currentWp.id + 1;
    if(nextId > 3) nextId = 1;
    currentWp = WEAPON_CONFIG[nextId];
    document.getElementById('weapon-id').innerText = currentWp.id;
    const diffBonus = (1 + difficultyLevel * DIFFICULTY_CONFIG.speedIncrease);
    fireTimer = currentWp.fireInterval / diffBonus;
    resetOverload();
    if(currentWp.id === 3) {
        wp3IdleStartTime = Date.now();
        idleTriggered = false;
        isLocked = false;
        document.getElementById('status-bar').innerText = "";
    }
}

function resetOverload() { 
    speedMultiplier = 1.0; 
    overloadFrames = 0; 
    wp3IdleStartTime = Date.now();
    document.getElementById('overload-info').style.visibility = 'hidden'; 
    document.getElementById('speed-bonus').innerText = "0";
}

function takeDamage() {
    const now = Date.now();
    if (now - player.lastHurtTime > INVULNERABLE_TIME) {
        player.hp--;
        player.lastHurtTime = now;
        document.getElementById('hp-val').innerText = Math.max(0, player.hp);
        if (player.hp <= 0) {
            alert("遊戲結束！分數: " + score);
            location.reload();
        }
    }
}

const tpBtn = document.getElementById('tp-btn');
tpBtn.addEventListener('touchstart', e => {
    e.preventDefault();
    if(tpCooldown > 0) return;
    const t = e.changedTouches[0];
    joyT.active = true;
    joyT.id = t.identifier;
    joyT.x1 = joyT.x2 = t.clientX;
    joyT.y1 = joyT.y2 = t.clientY;
    tpTarget = { x: player.x, y: player.y };
}, {passive: false});

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    for(let t of e.changedTouches) {
        if(t.clientX < canvas.width/2) {
            joyL.active = true;
            joyL.x1 = joyL.x2 = t.clientX;
            joyL.y1 = joyL.y2 = t.clientY;
            joyL.id = t.identifier;
        } else {
            joyR.active = true;
            joyR.x1 = joyR.x2 = t.clientX;
            joyR.y1 = joyR.y2 = t.clientY;
            joyR.id = t.identifier;
        }
    }
}, {passive: false});

window.addEventListener('touchmove', e => {
    for(let t of e.changedTouches) {
        if(joyL.id === t.identifier) {
            joyL.x2 = t.clientX;
            joyL.y2 = t.clientY;
        }
        if(joyR.id === t.identifier) {
            joyR.x2 = t.clientX;
            joyR.y2 = t.clientY;
        }
        if(joyT.id === t.identifier) {
            joyT.x2 = t.clientX;
            joyT.y2 = t.clientY;
            tpTarget.x = player.x + (joyT.x2 - joyT.x1) * 3.5;
            tpTarget.y = player.y + (joyT.y2 - joyT.y1) * 3.5;
        }
    }
}, {passive: false});

window.addEventListener('touchend', e => {
    for(let t of e.changedTouches) {
        if(joyL.id === t.identifier) {
            joyL.active = false;
            joyL.id = -1;
        }
        if(joyR.id === t.identifier) {
            joyR.active = false;
            joyR.id = -1;
        }
        if(joyT.id === t.identifier) {
            player.x = Math.max(20, Math.min(canvas.width-20, tpTarget.x));
            player.y = Math.max(20, Math.min(canvas.height-20, tpTarget.y));
            tpCooldown = TP_COOLDOWN_TIME;
            joyT.active = false;
            joyT.id = -1;
        }
    }
}, {passive: false});

document.getElementById('weapon-btn').addEventListener('touchstart', e => {
    e.preventDefault();
    switchWp();
});

function spawnEnemy() {
    const side = Math.floor(Math.random() * 4);
    let x, y;
    if(side === 0) { x = Math.random() * canvas.width; y = -80; }
    else if(side === 1) { x = canvas.width + 80; y = Math.random() * canvas.height; }
    else if(side === 2) { x = Math.random() * canvas.width; y = canvas.height + 80; }
    else { x = -80; y = Math.random() * canvas.height; }
    const rand = Math.random() * 100;
    let type = (rand < 68.5) ? ENEMY_CONFIG[1] : (rand < 83.5) ? ENEMY_CONFIG[2] : (rand < 98.5) ? ENEMY_CONFIG[3] : ENEMY_CONFIG[4];
    enemies.push({
        ...type,
        x, y,
        hp: type.hpBase * (1 + difficultyLevel * DIFFICULTY_CONFIG.hpIncrease),
        lastShootTime: Date.now(),
        lastHitTime: 0
    });
}

function spawnBullet(angle, offset, speed, isEnemy = false, ex = 0, ey = 0, dmg = 1) {
    const b = {
        x: isEnemy ? ex : (player.x + Math.cos(angle + Math.PI/2) * offset),
        y: isEnemy ? ey : (player.y + Math.sin(angle + Math.PI/2) * offset),
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        dmg: dmg
    };
    if(isEnemy) enemyBullets.push(b); else bullets.push(b);
}

function update() {
    const now = Date.now();
    const diffBonus = (1 + difficultyLevel * DIFFICULTY_CONFIG.speedIncrease);

    if(tpCooldown > 0) { 
        tpCooldown -= 16; 
        document.getElementById('tp-cd-overlay').style.transform = "scaleY(" + (tpCooldown / TP_COOLDOWN_TIME) + ")"; 
    }

    if(!boss && !isTransitioning && ++spawnTimer > (ENEMY_CONFIG.spawnRateBase / (1 + difficultyLevel * DIFFICULTY_CONFIG.spawnIncrease))) {
        spawnEnemy();
        spawnTimer = 0;
    }

    if(joyL.active) {
        const dx = joyL.x2 - joyL.x1, dy = joyL.y2 - joyL.y1, d = Math.hypot(dx, dy);
        if(d > 2) {
            player.x += (dx/d) * PLAYER_SPEED;
            player.y += (dy/d) * PLAYER_SPEED;
            if(currentWp.id === 3 && !isLocked) resetOverload();
        }
    }

    if(score >= BOSS_CONFIG[101].triggerScore && !b101Triggered) {
        b101Triggered = true;
        triggerBossTransition(101);
    }

    if(boss) {
        if(boss.id === 101) {
            const bh = boss.behavior;
            if(boss.y < bh.targetY) {
                boss.y += bh.entrySpeed;
            } else {
                boss.angle += bh.swingSpeed;
                boss.x = (canvas.width / 2) + Math.sin(boss.angle) * (canvas.width * bh.swingRange);
                if(now - boss.lastShootTime > bh.shootDelay) {
                    const ang = Math.atan2(player.y - boss.y, player.x - boss.x);
                    spawnBullet(ang, 0, bh.bulletSpeed, true, boss.x, boss.y);
                    boss.lastShootTime = now;
                }
            }
        }
    }

    if(currentWp.id === 3 && !isLocked) {
        const idleSec = (now - wp3IdleStartTime) / 1000;
        if(idleSec >= currentWp.overloadTriggerTime) {
            document.getElementById('overload-info').style.visibility = 'visible';
            if(++overloadFrames % 12 === 0) {
                speedMultiplier += currentWp.overloadIncrement;
                document.getElementById('speed-bonus').innerText = Math.round((speedMultiplier-1)*100);
            }
        }
        if(idleSec >= currentWp.ultimateTriggerTime && !idleTriggered) {
            for(let i=0; i<10; i++) spawnBullet((i/10) * Math.PI * 2, 0, 8, false, 0, 0, currentWp.damage);
            idleTriggered = true;
            isLocked = true;
            document.getElementById('status-bar').innerText = "系統過熱！";
            setTimeout(() => {
                isLocked = false;
                idleTriggered = false;
                document.getElementById('status-bar').innerText = "";
                resetOverload();
            }, currentWp.lockoutDuration * 1000);
        }
    }

    if(joyR.active) {
        const dx = joyR.x2 - joyR.x1, dy = joyR.y2 - joyR.y1;
        if(Math.hypot(dx, dy) > 2) lastAngle = Math.atan2(dy, dx);
    }

    if (!isLocked && --fireTimer <= 0) {
        const interval = (currentWp.id === 3 ? (currentWp.fireInterval / speedMultiplier) : currentWp.fireInterval) / diffBonus;
        if(currentWp.id === 1) {
            spawnBullet(lastAngle, 0, currentWp.speed, false, 0, 0, currentWp.damage);
        } else if(currentWp.id === 2) {
            for(let i=0; i<15; i++) spawnBullet(lastAngle - (15*Math.PI/180) + i*(2*Math.PI/180), 0, currentWp.speed, false, 0, 0, currentWp.damage);
        } else if(currentWp.id === 3) {
            spawnBullet(lastAngle, 12, currentWp.speed, false, 0, 0, currentWp.damage);
            spawnBullet(lastAngle, -12, currentWp.speed, false, 0, 0, currentWp.damage);
        }
        fireTimer = Math.max(2, interval);
    }

    if(boss) {
        for (let bIdx = bullets.length - 1; bIdx >= 0; bIdx--) {
            let b = bullets[bIdx];
            if(Math.hypot(b.x - boss.x, b.y - boss.y) < boss.size) {
                boss.hp -= b.dmg;
                boss.lastHitTime = now;
                bullets.splice(bIdx, 1);
                if(boss.hp <= 0) {
                    score += boss.score;
                    document.getElementById('score-val').innerText = score;
                    updateDifficulty();
                    document.getElementById('status-bar').innerText = "BOSS DEFEATED!";
                    setTimeout(() => document.getElementById('status-bar').innerText = "", 3000);
                    boss = null;
                    break;
                }
            }
        }
    }

    for (let eIdx = enemies.length - 1; eIdx >= 0; eIdx--) {
        let en = enemies[eIdx];
        const dx = player.x - en.x;
        const dy = player.y - en.y;
        const dist = Math.hypot(dx, dy);
        en.x += (dx/dist) * en.speed;
        en.y += (dy/dist) * en.speed;
        
        if (dist < en.size + player.size/2) takeDamage();
        
        if(en.shootInterval > 0 && now - en.lastShootTime > en.shootInterval * 1000) {
            const ang = Math.atan2(dy, dx);
            if(en.id === 2) spawnBullet(ang, 0, en.bulletSpeed, true, en.x, en.y);
            else if(en.id === 3) for(let i=-1; i<=1; i++) spawnBullet(ang + i*15*Math.PI/180, 0, en.bulletSpeed, true, en.x, en.y);
            else if(en.id === 4) for(let i=0; i<5; i++) spawnBullet(ang + (i * 72 * Math.PI/180), 0, en.bulletSpeed, true, en.x, en.y);
            en.lastShootTime = now;
        }
        
        for (let bIdx = bullets.length - 1; bIdx >= 0; bIdx--) {
            let b = bullets[bIdx];
            if(Math.hypot(b.x - en.x, b.y - en.y) < en.size + 4) {
                en.hp -= b.dmg;
                en.lastHitTime = now;
                bullets.splice(bIdx, 1);
                if(en.hp <= 0) {
                    score += en.score;
                    document.getElementById('score-val').innerText = score;
                    updateDifficulty();
                    if(Math.random() < en.dropRate) drops.push({x: en.x, y: en.y, heal: 10});
                    enemies.splice(eIdx, 1);
                    break;
                }
            }
        }
    }
    
    drops.forEach((d, i) => {
        if(Math.hypot(d.x - player.x, d.y - player.y) < player.size + 10) {
            player.hp = Math.min(player.maxHp, player.hp + d.heal);
            document.getElementById('hp-val').innerText = player.hp;
            drops.splice(i, 1);
        }
    });

    enemyBullets.forEach((eb, i) => {
        if(Math.hypot(eb.x - player.x, eb.y - player.y) < player.size/2 + 4) {
            takeDamage();
            enemyBullets.splice(i, 1);
        }
    });

    [bullets, enemyBullets].forEach(arr => {
        for(let i=arr.length-1; i>=0; i--) {
            arr[i].x += arr[i].vx;
            arr[i].y += arr[i].vy;
            if(arr[i].x<0 || arr[i].x>canvas.width || arr[i].y<0 || arr[i].y>canvas.height) arr.splice(i, 1);
        }
    });
    
    player.x = Math.max(20, Math.min(canvas.width-20, player.x));
    player.y = Math.max(20, Math.min(canvas.height-20, player.y));
}

function draw() {
    const now = Date.now();
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    
    drops.forEach(d => {
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(d.x-8, d.y-8, 16, 16);
        ctx.fillStyle = '#fff';
        ctx.fillRect(d.x-2, d.y-6, 4, 12);
        ctx.fillRect(d.x-6, d.y-2, 12, 4);
    });

    enemies.forEach(en => {
        ctx.fillStyle = (now - en.lastHitTime < HIT_FLASH_DURATION) ? 'rgba(255, 255, 255, 0.45)' : en.color;
        if(en.id === 4 && now - en.lastHitTime >= HIT_FLASH_DURATION) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#FFD700';
        }
        ctx.beginPath();
        ctx.arc(en.x, en.y, en.size, 0, 7);
        ctx.fill();
        ctx.shadowBlur = 0;
    });

    if(boss) {
        ctx.fillStyle = (now - boss.lastHitTime < HIT_FLASH_DURATION) ? 'rgba(255, 255, 255, 0.45)' : boss.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#fff';
        ctx.beginPath();
        ctx.roundRect(boss.x - boss.size, boss.y - boss.size, boss.size * 2, boss.size * 2, 12);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = '#444';
        ctx.fillRect(boss.x - 50, boss.y - boss.size - 15, 100, 8);
        ctx.fillStyle = '#f00';
        ctx.fillRect(boss.x - 50, boss.y - boss.size - 15, (boss.hp / boss.maxHp) * 100, 8);
    }

    if(joyT.active) {
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(tpTarget.x, tpTarget.y, 25, 0, 7);
        ctx.stroke();
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(player.x, player.y);
        ctx.lineTo(tpTarget.x, tpTarget.y);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    if (!(Date.now() - player.lastHurtTime < INVULNERABLE_TIME) || Math.floor(now/50) % 2) {
        let pColor = isLocked ? '#444' : (currentWp.id === 3 && document.getElementById('overload-info').style.visibility === 'visible' ? '#ff3300' : currentWp.color);
        ctx.fillStyle = pColor;
        ctx.fillRect(player.x - 8, player.y - 8, 16, 16);
    }
    
    ctx.fillStyle = '#fff';
    bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, 3.5, 0, 7); ctx.fill(); });
    ctx.fillStyle = '#f00';
    enemyBullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, 7); ctx.fill(); });
    
    if(joyL.active) drawJoy(joyL, '#00ccff');
    if(joyR.active) drawJoy(joyR, '#ff3300');
    
    update();
    requestAnimationFrame(draw);
}

function drawJoy(j, c) {
    ctx.beginPath();
    ctx.arc(j.x1, j.y1, 45, 0, 7);
    ctx.strokeStyle = c+'33';
    ctx.lineWidth=3;
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(j.x2, j.y2, 22, 0, 7);
    ctx.fillStyle = c+'66';
    ctx.fill();
}

draw();
</script>
</body>
</html>
