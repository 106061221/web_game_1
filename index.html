<!DOCTYPE html>
<html>
<head>
    <title>工具箱挑戰 - 8x8 完美填滿</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; background: #2c3e50; font-family: sans-serif; touch-action: none; }
        canvas { background: #ecf0f1; border: 4px solid #34495e; box-shadow: 0 10px 20px rgba(0,0,0,0.3); max-width: 95vw; max-height: 80vh; }
        .hint { color: white; margin-bottom: 10px; }
    </style>
</head>
<body>

<div class="hint">目標：將所有工具放入 8x8 箱子內</div>
<canvas id="gameCanvas" width="400" height="650"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const GRID_SIZE = 45;
const BOARD_POS = { x: 20, y: 50 };
const BOARD_DIM = { rows: 8, cols: 8 };

// 定義工具物件與形狀 (總共 64 格)
let pieces = [
    { name: "大槌子", color: "#E74C3C", x: 20, y: 430, isDragging: false, 
      shape: [{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:0,y:1},{x:1,y:1},{x:2,y:1},{x:1,y:2},{x:1,y:3},{x:1,y:4},{x:1,y:5}] }, // 10格
    { name: "長扳手", color: "#F1C40F", x: 180, y: 430, isDragging: false, 
      shape: [{x:0,y:0},{x:0,y:1},{x:1,y:1},{x:2,y:1},{x:3,y:1},{x:4,y:1},{x:4,y:0},{x:2,y:2}] }, // 8格
    { name: "鋸子", color: "#95A5A6", x: 20, y: 530, isDragging: false, 
      shape: [{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},{x:0,y:1},{x:1,y:1},{x:2,y:1},{x:3,y:1},{x:0,y:2},{x:1,y:2},{x:2,y:2}] }, // 12格
    { name: "螺絲起子", color: "#3498DB", x: 280, y: 430, isDragging: false, 
      shape: [{x:0,y:0},{x:0,y:1},{x:0,y:2},{x:0,y:3},{x:0,y:4},{x:0,y:5}] }, // 6格
    { name: "鉗子", color: "#1ABC9C", x: 180, y: 530, isDragging: false, 
      shape: [{x:0,y:0},{x:1,y:0},{x:0,y:1},{x:1,y:1},{x:0,y:2},{x:1,y:2},{x:0,y:3},{x:1,y:3}] }, // 8格
    { name: "美工刀", color: "#D35400", x: 280, y: 530, isDragging: false, 
      shape: [{x:0,y:0},{x:1,y:0},{x:0,y:1},{x:1,y:1},{x:0,y:2},{x:1,y:2},{x:0,y:3},{x:1,y:3},{x:0,y:4},{x:1,y:4}] }, // 10格
    { name: "L型尺", color: "#8E44AD", x: 10, y: 430, isDragging: false, 
      shape: [{x:0,y:0},{x:0,y:1},{x:0,y:2},{x:0,y:3},{x:1,y:3},{x:2,y:3},{x:3,y:3},{x:4,y:3},{x:5,y:3},{x:6,y:3}] } // 10格
];

let activePiece = null;
let offset = { x: 0, y: 0 };

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 1. 繪製箱子網格
    ctx.fillStyle = "#fff";
    ctx.fillRect(BOARD_POS.x, BOARD_POS.y, BOARD_DIM.cols * GRID_SIZE, BOARD_DIM.rows * GRID_SIZE);
    ctx.strokeStyle = '#bdc3c7';
    ctx.lineWidth = 1;
    for (let r = 0; r <= BOARD_DIM.rows; r++) {
        ctx.beginPath();
        ctx.moveTo(BOARD_POS.x, BOARD_POS.y + r * GRID_SIZE);
        ctx.lineTo(BOARD_POS.x + BOARD_DIM.cols * GRID_SIZE, BOARD_POS.y + r * GRID_SIZE);
        ctx.stroke();
    }
    for (let c = 0; c <= BOARD_DIM.cols; c++) {
        ctx.beginPath();
        ctx.moveTo(BOARD_POS.x + c * GRID_SIZE, BOARD_POS.y);
        ctx.lineTo(BOARD_POS.x + c * GRID_SIZE, BOARD_POS.y + BOARD_DIM.rows * GRID_SIZE);
        ctx.stroke();
    }

    // 2. 繪製所有物件 (先畫沒被抓取的， activePiece 最後畫以免被遮擋)
    pieces.forEach(p => {
        if (p === activePiece) return;
        drawPiece(p);
    });
    if (activePiece) drawPiece(activePiece);

    requestAnimationFrame(draw);
}

function drawPiece(p) {
    ctx.fillStyle = p.color;
    ctx.strokeStyle = "#2c3e50";
    ctx.lineWidth = 2;
    p.shape.forEach(cell => {
        const px = p.x + cell.x * GRID_SIZE;
        const py = p.y + cell.y * GRID_SIZE;
        ctx.fillRect(px, py, GRID_SIZE, GRID_SIZE);
        ctx.strokeRect(px, py, GRID_SIZE, GRID_SIZE);
    });
}

function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top };
}

function handleStart(e) {
    const pos = getPos(e);
    // 逆向遍歷，確保抓到最上層的物件
    for (let i = pieces.length - 1; i >= 0; i--) {
        const p = pieces[i];
        for (let cell of p.shape) {
            const cx = p.x + cell.x * GRID_SIZE;
            const cy = p.y + cell.y * GRID_SIZE;
            if (pos.x >= cx && pos.x <= cx + GRID_SIZE && pos.y >= cy && pos.y <= cy + GRID_SIZE) {
                activePiece = p;
                offset.x = pos.x - p.x;
                offset.y = pos.y - p.y;
                return;
            }
        }
    }
}

function handleMove(e) {
    if (!activePiece) return;
    e.preventDefault();
    const pos = getPos(e);
    activePiece.x = pos.x - offset.x;
    activePiece.y = pos.y - offset.y;
}

function handleEnd() {
    if (!activePiece) return;
    
    // 簡易吸附與範圍判定
    // 判斷是否靠近箱子
    if (activePiece.x > BOARD_POS.x - GRID_SIZE && activePiece.x < BOARD_POS.x + BOARD_DIM.cols * GRID_SIZE) {
        activePiece.x = Math.round((activePiece.x - BOARD_POS.x) / GRID_SIZE) * GRID_SIZE + BOARD_POS.x;
        activePiece.y = Math.round((activePiece.y - BOARD_POS.y) / GRID_SIZE) * GRID_SIZE + BOARD_POS.y;
    }
    
    activePiece = null;
}

canvas.addEventListener('mousedown', handleStart);
window.addEventListener('mousemove', handleMove);
window.addEventListener('mouseup', handleEnd);
canvas.addEventListener('touchstart', handleStart);
window.addEventListener('touchmove', handleMove, { passive: false });
window.addEventListener('touchend', handleEnd);

draw();
</script>
</body>
</html>
