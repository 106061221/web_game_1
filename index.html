<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>模組化射擊 - 獨立換彈版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0a; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; background: #000; }
        #ui { position: absolute; top: 20px; left: 20px; color: #fff; pointer-events: none; }
        .weapon-tag { font-weight: bold; font-size: 24px; color: #00ffcc; }
        
        /* 換武器按鈕樣式 */
        #weapon-btn {
            position: absolute;
            right: 40px;
            bottom: 220px; /* 位於右搖桿上方 */
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #00ffcc;
            border-radius: 50%;
            color: #00ffcc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            user-select: none;
            touch-action: manipulation;
        }
        #weapon-btn:active {
            background: rgba(0, 255, 204, 0.4);
            transform: scale(0.9);
        }

        #status-bar { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: #ff3300; font-size: 18px; font-weight: bold; pointer-events: none;}
    </style>
</head>
<body>
    <div id="ui">
        <div class="weapon-tag">武器編號: <span id="weapon-id">1</span></div>
        <div id="overload-info" style="visibility:hidden; color: #ff3300;">超載攻速: +<span id="speed-bonus">0</span>%</div>
    </div>
    
    <div id="weapon-btn">換武器</div>
    
    <div id="status-bar"></div>
    <canvas id="gameCanvas"></canvas>

<script>
/** * ==========================================
 * 武器參數設定區
 * ========================================== */
const WEAPON_CONFIG = {
    1: { id: 1, fireInterval: 10, bulletCount: 1, spread: 0, speed: 12, color: '#fff' },
    2: { id: 2, fireInterval: 150, bulletCount: 15, spread: 30, speed: 10, color: '#ffcc00' },
    3: { 
        id: 3, fireInterval: 22, bulletCount: 2, speed: 14, color: '#00ccff',
        overloadTriggerTime: 0.5, overloadTickRate: 0.2, overloadIncrement: 0.1,
        ultimateTriggerTime: 3.0, ultimateBulletScale: 2.0, lockoutDuration: 2.0 
    }
};

const PLAYER_SPEED = 3.0;
const DEADZONE_LEFT = 20;  // 已調小死區
const DEADZONE_RIGHT = 25; 

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let player = { x: canvas.width/2, y: canvas.height/2 };
let bullets = [];
let currentWp = WEAPON_CONFIG[1];
let fireTimer = 0;
let lastMoveTime = Date.now();
let speedMultiplier = 1.0;
let overloadFrames = 0;
let isLocked = false;
let idleTriggered = false;

let joyL = { active: false, x1: 0, y1: 0, x2: 0, y2: 0, id: -1 };
let joyR = { active: false, x1: 0, y1: 0, x2: 0, y2: 0, id: -1 };

// 換武器按鈕邏輯
const btn = document.getElementById('weapon-btn');
btn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    switchWp();
});

function switchWp() {
    let nextId = currentWp.id + 1;
    if(nextId > 3) nextId = 1;
    currentWp = WEAPON_CONFIG[nextId];
    document.getElementById('weapon-id').innerText = currentWp.id;
    resetOverload();
}

// 搖桿事件處理
canvas.addEventListener('touchstart', e => {
    for(let t of e.changedTouches) {
        if(t.clientX < canvas.width/2) {
            joyL.active = true; joyL.x1 = joyL.x2 = t.clientX; joyL.y1 = joyL.y2 = t.clientY;
            joyL.id = t.identifier;
        } else {
            joyR.active = true; joyR.x1 = joyR.x2 = t.clientX; joyR.y1 = joyR.y2 = t.clientY;
            joyR.id = t.identifier;
        }
    }
});

canvas.addEventListener('touchmove', e => {
    for(let t of e.changedTouches) {
        if(joyL.id === t.identifier) { joyL.x2 = t.clientX; joyL.y2 = t.clientY; }
        if(joyR.id === t.identifier) { joyR.x2 = t.clientX; joyR.y2 = t.clientY; }
    }
});

canvas.addEventListener('touchend', e => {
    for(let t of e.changedTouches) {
        if(joyL.id === t.identifier) { joyL.active = false; joyL.id = -1; }
        if(joyR.id === t.identifier) { joyR.active = false; joyR.id = -1; }
    }
});

function resetOverload() {
    speedMultiplier = 1.0;
    overloadFrames = 0;
    document.getElementById('overload-info').style.visibility = 'hidden';
}

function spawnBullet(angle, offset, speed) {
    bullets.push({
        x: player.x + Math.cos(angle + Math.PI/2) * offset,
        y: player.y + Math.sin(angle + Math.PI/2) * offset,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed
    });
}

function update() {
    const now = Date.now();
    
    // 移動邏輯
    if(joyL.active) {
        const dx = joyL.x2 - joyL.x1, dy = joyL.y2 - joyL.y1, d = Math.hypot(dx, dy);
        if(d > DEADZONE_LEFT) {
            player.x += (dx/d) * PLAYER_SPEED; player.y += (dy/d) * PLAYER_SPEED;
            lastMoveTime = now; idleTriggered = false; resetOverload();
        }
    }

    // 武器三特殊邏輯
    if(currentWp.id === 3 && !isLocked) {
        const idleSec = (now - lastMoveTime)/1000;
        if(idleSec >= currentWp.overloadTriggerTime) {
            document.getElementById('overload-info').style.visibility = 'visible';
            overloadFrames++;
            if(overloadFrames % Math.floor(currentWp.overloadTickRate * 60) === 0) {
                speedMultiplier += currentWp.overloadIncrement;
                document.getElementById('speed-bonus').innerText = Math.round((speedMultiplier-1)*100);
            }
        }
        if(idleSec >= currentWp.ultimateTriggerTime && !idleTriggered) {
            const count = Math.floor((120 / (currentWp.fireInterval/speedMultiplier)) * currentWp.ultimateBulletScale);
            for(let i=0; i<count; i++) spawnBullet((i/count)*Math.PI*2, 0, 8);
            idleTriggered = true; isLocked = true;
            document.getElementById('status-bar').innerText = "系統過熱！冷卻中...";
            setTimeout(() => { isLocked = false; document.getElementById('status-bar').innerText = ""; }, currentWp.lockoutDuration * 1000);
            resetOverload();
        }
    }

    // 射擊方向控制
    if(joyR.active) {
        const dx = joyR.x2 - joyR.x1, dy = joyR.y2 - joyR.y1, d = Math.hypot(dx, dy);
        if(d > DEADZONE_RIGHT && !isLocked && fireTimer <= 0) {
            const angle = Math.atan2(dy, dx);
            const interval = currentWp.id === 3 ? (currentWp.fireInterval / speedMultiplier) : currentWp.fireInterval;
            
            if(currentWp.id === 1) spawnBullet(angle, 0, currentWp.speed);
            else if(currentWp.id === 2) {
                const start = angle - (currentWp.spread * Math.PI/180)/2;
                const step = (currentWp.spread * Math.PI/180) / (currentWp.bulletCount - 1);
                for(let i=0; i<currentWp.bulletCount; i++) spawnBullet(start + i*step, 0, currentWp.speed);
            }
            else if(currentWp.id === 3) {
                spawnBullet(angle, 12, currentWp.speed); spawnBullet(angle, -12, currentWp.speed);
            }
            fireTimer = interval;
        }
    }

    if(fireTimer > 0) fireTimer--;
    player.x = Math.max(20, Math.min(canvas.width-20, player.x));
    player.y = Math.max(20, Math.min(canvas.height-20, player.y));
    bullets = bullets.filter(b => {
        b.x += b.vx; b.y += b.vy;
        return !(b.x<0 || b.x>canvas.width || b.y<0 || b.y>canvas.height);
    });
}

function draw() {
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
    
    // 繪製格線背景
    ctx.strokeStyle = '#111';
    for(let i=0; i<canvas.width; i+=40) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); ctx.stroke(); }

    // 繪製玩家
    ctx.fillStyle = isLocked ? '#444' : currentWp.color;
    ctx.shadowBlur = isLocked ? 0 : 15; ctx.shadowColor = currentWp.color;
    ctx.fillRect(player.x-15, player.y-15, 30, 30);
    ctx.shadowBlur = 0;

    // 繪製子彈
    ctx.fillStyle = '#fff';
    bullets.forEach(b => ctx.fillRect(b.x-2, b.y-2, 4, 4));

    // 繪製搖桿視覺
    if(joyL.active) drawJoy(joyL, '#00ccff');
    if(joyR.active) drawJoy(joyR, '#ff3300');

    update();
    requestAnimationFrame(draw);
}

function drawJoy(j, c) {
    ctx.beginPath(); ctx.arc(j.x1, j.y1, 50, 0, 7); ctx.strokeStyle = c+'33'; ctx.lineWidth=2; ctx.stroke();
    ctx.beginPath(); ctx.arc(j.x2, j.y2, 25, 0, 7); ctx.fillStyle = c+'66'; ctx.fill();
}

draw();
</script>
</body>
</html>
