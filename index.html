<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>雙搖桿射擊遊戲 - 簡約版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: Arial; touch-action: none; }
        canvas { display: block; background: #000; border: 5px solid #333; box-sizing: border-box; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div>武器編號: <span id="weapon-id">1</span></div>
        <div style="margin-top:5px; font-size: 12px; color: #aaa;">右手連點兩下：換武器<br>右手搖桿：控制射擊方向</div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const weaponText = document.getElementById('weapon-id');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// 遊戲狀態
const player = { x: canvas.width/2, y: canvas.height/2, size: 20, speed: 3.5, color: '#00ccff' };
let bullets = [];
let weaponIndex = 0; 
const deadzone = 40; 

// 搖桿與點擊狀態
let leftJoystick = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };
let rightJoystick = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };
let lastRightTouchTime = 0; // 用於偵測右手連點

canvas.addEventListener('touchstart', (e) => {
    const now = Date.now();
    for (let touch of e.changedTouches) {
        if (touch.clientX < canvas.width / 2) {
            // 左半邊：移動
            leftJoystick.active = true;
            leftJoystick.startX = leftJoystick.currX = touch.clientX;
            leftJoystick.startY = leftJoystick.currY = touch.clientY;
        } else {
            // 右半邊：射擊方向 + 連點換武器
            rightJoystick.active = true;
            rightJoystick.startX = rightJoystick.currX = touch.clientX;
            rightJoystick.startY = rightJoystick.currY = touch.clientY;
            
            if (now - lastRightTouchTime < 300) {
                switchWeapon();
            }
            lastRightTouchTime = now;
        }
    }
});

canvas.addEventListener('touchmove', (e) => {
    for (let touch of e.changedTouches) {
        if (leftJoystick.active && touch.clientX < canvas.width/2) {
            leftJoystick.currX = touch.clientX;
            leftJoystick.currY = touch.clientY;
        }
        if (rightJoystick.active && touch.clientX >= canvas.width/2) {
            rightJoystick.currX = touch.clientX;
            rightJoystick.currY = touch.clientY;
        }
    }
});

canvas.addEventListener('touchend', (e) => {
    for (let touch of e.changedTouches) {
        if (touch.clientX < canvas.width/2) leftJoystick.active = false;
        else rightJoystick.active = false;
    }
});

function switchWeapon() {
    weaponIndex = (weaponIndex + 1) % 3;
    weaponText.innerText = weaponIndex + 1;
}

function fire(angle) {
    if (weaponIndex === 0) {
        createBullet(angle);
    } else if (weaponIndex === 1) {
        createBullet(angle - 0.2);
        createBullet(angle);
        createBullet(angle + 0.2);
    } else if (weaponIndex === 2) {
        createBullet(angle, 12);
        createBullet(angle, -12);
    }
}

function createBullet(angle, offset = 0) {
    bullets.push({
        x: player.x + Math.cos(angle + Math.PI/2) * offset,
        y: player.y + Math.sin(angle + Math.PI/2) * offset,
        vx: Math.cos(angle) * 12,
        vy: Math.sin(angle) * 12
    });
}

let frameCount = 0;
function update() {
    // 1. 移動玩家
    if (leftJoystick.active) {
        const dx = leftJoystick.currX - leftJoystick.startX;
        const dy = leftJoystick.currY - leftJoystick.startY;
        const dist = Math.hypot(dx, dy);
        if (dist > deadzone) {
            player.x += (dx / dist) * player.speed;
            player.y += (dy / dist) * player.speed;
        }
    }

    // 2. 射擊方向控制 (右搖桿)
    if (rightJoystick.active) {
        const dx = rightJoystick.currX - rightJoystick.startX;
        const dy = rightJoystick.currY - rightJoystick.startY;
        const dist = Math.hypot(dx, dy);
        if (dist > 10) {
            const angle = Math.atan2(dy, dx);
            if (frameCount % 8 === 0) fire(angle); 
        }
    }

    // 邊界限制
    player.x = Math.max(20, Math.min(canvas.width - 20, player.x));
    player.y = Math.max(20, Math.min(canvas.height - 20, player.y));

    // 更新子彈
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx; b.y += b.vy;
        if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
            bullets.splice(i, 1);
        }
    }

    frameCount++;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 畫玩家
    ctx.fillStyle = player.color;
    ctx.shadowBlur = 10;
    ctx.shadowColor = player.color;
    ctx.fillRect(player.x - 15, player.y - 15, 30, 30);
    ctx.shadowBlur = 0;

    // 畫子彈
    ctx.fillStyle = '#ff0';
    bullets.forEach(b => ctx.fillRect(b.x - 3, b.y - 3, 6, 6));

    // 畫搖桿提示
    if (leftJoystick.active) drawJoystick(leftJoystick, "#00ccff");
    if (rightJoystick.active) drawJoystick(rightJoystick, "#ff0000");

    update();
    requestAnimationFrame(draw);
}

function drawJoystick(joy, color) {
    ctx.beginPath();
    ctx.arc(joy.startX, joy.startY, 50, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.lineWidth = 2;
    ctx.stroke();
    
    ctx.beginPath();
    ctx.arc(joy.currX, joy.currY, 25, 0, Math.PI*2);
    ctx.fillStyle = color + "44";
    ctx.fill();
}

draw();
</script>
</body>
</html>
