<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>工具裝箱 - 100% 逆向切割版</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; background: #2c3e50; font-family: sans-serif; touch-action: none; }
        .controls { margin-bottom: 15px; display: flex; gap: 10px; }
        button { padding: 12px 24px; font-size: 16px; font-weight: bold; cursor: pointer; background: #27ae60; color: white; border: none; border-radius: 8px; box-shadow: 0 4px #1e8449; }
        button:active { box-shadow: 0 0px #1e8449; transform: translateY(4px); }
        canvas { background: #ecf0f1; border: 5px solid #34495e; max-width: 95vw; max-height: 75vh; }
    </style>
</head>
<body>

<div class="controls">
    <button onclick="showSolution()">公佈答案</button>
    <button style="background:#e67e22; box-shadow:0 4px #d35400" onclick="location.reload()">重置</button>
</div>
<canvas id="gameCanvas" width="400" height="640"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const GRID_SIZE = 42;
const BOARD_POS = { x: 33, y: 40 };

// 核心數據：將 8x8 (64格) 嚴格切割為 6 個物件，絕不重疊
let pieces = [
    { name: "大型槌", color: "#E74C3C", x: 20, y: 410, sol: {x:0, y:0}, 
      shape: [{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:0,y:1},{x:1,y:1},{x:2,y:1},{x:1,y:2},{x:1,y:3},{x:1,y:4},{x:1,y:5},{x:1,y:6},{x:1,y:7}] }, // 12格
    { name: "長鋸子", color: "#95A5A6", x: 160, y: 410, sol: {x:3, y:0}, 
      shape: [{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},{x:0,y:1},{x:1,y:1},{x:2,y:1},{x:3,y:1},{x:4,y:1},{x:0,y:2},{x:1,y:2}] }, // 12格
    { name: "直角尺", color: "#8E44AD", x: 300, y: 410, sol: {x:5, y:2}, 
      shape: [{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:0,y:1},{x:0,y:2},{x:0,y:3},{x:0,y:4},{x:0,y:5},{x:1,y:5},{x:2,y:5}] }, // 10格
    { name: "扳手", color: "#F1C40F", x: 20, y: 530, sol: {x:0, y:2}, 
      shape: [{x:0,y:0},{x:0,y:1},{x:0,y:2},{x:0,y:3},{x:0,y:4},{x:0,y:5},{x:1,y:5},{x:2,y:5},{x:2,y:4},{x:2,y:3}] }, // 10格
    { name: "螺絲刀", color: "#3498DB", x: 160, y: 530, sol: {x:3, y:2}, 
      shape: [{x:0,y:0},{x:1,y:0},{x:0,y:1},{x:1,y:1},{x:0,y:2},{x:1,y:2},{x:0,y:3},{x:1,y:3},{x:0,y:4},{x:1,y:4}] }, // 10格
    { name: "鉗子", color: "#1ABC9C", x: 300, y: 530, sol: {x:3, y:7}, 
      shape: [{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},{x:0,y:-1},{x:1,y:-1},{x:2,y:-1},{x:3,y:-1},{x:4,y:-1}] } // 10格
];
// 校驗：12+12+10+10+10+10 = 64 格。

let activePiece = null;
let offset = { x: 0, y: 0 };

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // 繪製 8x8 容器
    ctx.fillStyle = "#fff";
    ctx.fillRect(BOARD_POS.x, BOARD_POS.y, 8 * GRID_SIZE, 8 * GRID_SIZE);
    ctx.strokeStyle = '#bdc3c7';
    for (let i = 0; i <= 8; i++) {
        ctx.beginPath(); ctx.moveTo(BOARD_POS.x, BOARD_POS.y + i * GRID_SIZE); ctx.lineTo(BOARD_POS.x + 8 * GRID_SIZE, BOARD_POS.y + i * GRID_SIZE); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(BOARD_POS.x + i * GRID_SIZE, BOARD_POS.y); ctx.lineTo(BOARD_POS.x + i * GRID_SIZE, BOARD_POS.y + 8 * GRID_SIZE); ctx.stroke();
    }
    // 繪製物件
    pieces.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.strokeStyle = "#2c3e50";
        p.shape.forEach(cell => {
            ctx.fillRect(p.x + cell.x * GRID_SIZE, p.y + cell.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
            ctx.strokeRect(p.x + cell.x * GRID_SIZE, p.y + cell.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
        });
    });
    requestAnimationFrame(draw);
}

function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top };
}

function handleStart(e) {
    const pos = getPos(e);
    for (let i = pieces.length - 1; i >= 0; i--) {
        const p = pieces[i];
        for (let cell of p.shape) {
            if (pos.x >= p.x + cell.x * GRID_SIZE && pos.x <= p.x + cell.x * GRID_SIZE + GRID_SIZE &&
                pos.y >= p.y + cell.y * GRID_SIZE && pos.y <= p.y + cell.y * GRID_SIZE + GRID_SIZE) {
                activePiece = p;
                offset.x = pos.x - p.x; offset.y = pos.y - p.y;
                return;
            }
        }
    }
}

function handleMove(e) {
    if (!activePiece) return;
    if (e.cancelable) e.preventDefault();
    const pos = getPos(e);
    activePiece.x = pos.x - offset.x; activePiece.y = pos.y - offset.y;
}

function handleEnd() {
    if (!activePiece) return;
    if (activePiece.x > BOARD_POS.x - GRID_SIZE && activePiece.x < BOARD_POS.x + 8 * GRID_SIZE) {
        activePiece.x = Math.round((activePiece.x - BOARD_POS.x) / GRID_SIZE) * GRID_SIZE + BOARD_POS.x;
        activePiece.y = Math.round((activePiece.y - BOARD_POS.y) / GRID_SIZE) * GRID_SIZE + BOARD_POS.y;
    }
    activePiece = null;
}

function showSolution() {
    pieces.forEach(p => {
        p.x = BOARD_POS.x + p.sol.x * GRID_SIZE;
        p.y = BOARD_POS.y + p.sol.y * GRID_SIZE;
    });
}

canvas.addEventListener('mousedown', handleStart);
window.addEventListener('mousemove', handleMove);
window.addEventListener('mouseup', handleEnd);
canvas.addEventListener('touchstart', handleStart, { passive: false });
window.addEventListener('touchmove', handleMove, { passive: false });
window.addEventListener('touchend', handleEnd);

draw();
</script>
</body>
</html>
