<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>生存射擊 - 玩家生命系統</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0a; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; background: #000; }
        #ui { position: absolute; top: 20px; left: 20px; color: #fff; pointer-events: none; z-index: 10; }
        .weapon-tag { font-weight: bold; font-size: 24px; color: #00ffcc; }
        #hp-bar { font-size: 20px; color: #ff5555; margin-top: 5px; font-weight: bold; }
        #overload-info { color: #ff3300; font-weight: bold; margin-top: 5px; visibility: hidden; }
        #weapon-btn {
            position: absolute; right: 40px; bottom: 220px; width: 80px; height: 80px;
            background: rgba(255, 255, 255, 0.1); border: 2px solid #00ffcc;
            border-radius: 50%; color: #00ffcc; display: flex; align-items: center;
            justify-content: center; font-weight: bold; font-size: 14px; z-index: 20;
        }
        #status-bar { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); color: #ff3300; font-size: 20px; font-weight: bold; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div class="weapon-tag">武器編號: <span id="weapon-id">1</span></div>
        <div id="hp-bar">HP: <span id="hp-val">30</span></div>
        <div id="overload-info">超載攻速: +<span id="speed-bonus">0</span>%</div>
    </div>
    <div id="weapon-btn">換武器</div>
    <div id="status-bar"></div>
    <canvas id="gameCanvas"></canvas>

<script>
/** * ==========================================
 * 1. 核心參數設定
 * ========================================== */
const WEAPON_CONFIG = {
    1: { id: 1, fireInterval: 10, bulletCount: 1, spread: 0, speed: 12, color: '#fff' },
    2: { id: 2, fireInterval: 150, bulletCount: 15, spread: 30, speed: 10, color: '#ffcc00' },
    3: { id: 3, fireInterval: 22, bulletCount: 2, speed: 14, color: '#00ccff', overloadTriggerTime: 0.5, overloadTickRate: 0.2, overloadIncrement: 0.1, ultimateTriggerTime: 3.0, ultimateBulletScale: 2.0, lockoutDuration: 2.0 }
};

const ENEMY_CONFIG = {
    spawnRate: 60,
    1: { id: 1, speed: 0.2, hp: 1, size: 20, color: '#ff5555', shootInterval: 0, weight: 70 },
    2: { id: 2, speed: 0.2, hp: 2, size: 25, color: '#ff00ff', shootInterval: 2, bulletSpeed: 0.7, weight: 15 },
    3: { id: 3, speed: 0.2, hp: 2, size: 25, color: '#ffff00', shootInterval: 7.0, bulletSpeed: 0.7, weight: 15 }
};

const PLAYER_SPEED = 2.0; 
const DEADZONE_LEFT = 10;  
const DEADZONE_RIGHT = 8;
const INVULNERABLE_TIME = 250; // 無敵時間 (ms)

/** * ==========================================
 * 2. 遊戲狀態
 * ========================================== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let player = { x: canvas.width/2, y: canvas.height/2, hp: 30, size: 21, lastHurtTime: 0 };
let bullets = [];      
let enemyBullets = []; 
let enemies = [];
let currentWp = WEAPON_CONFIG[1];
let fireTimer = 0;
let lastAngle = 0;
let spawnTimer = 0;

let wp3IdleStartTime = 0, speedMultiplier = 1.0, overloadFrames = 0, isLocked = false, idleTriggered = false;
let joyL = { active: false, x1: 0, y1: 0, x2: 0, y2: 0, id: -1 };
let joyR = { active: false, x1: 0, y1: 0, x2: 0, y2: 0, id: -1 };

/** * ==========================================
 * 3. 邏輯處理
 * ========================================== */
document.getElementById('weapon-btn').addEventListener('touchstart', e => { e.preventDefault(); switchWp(); });

function switchWp() {
    let nextId = currentWp.id + 1;
    if(nextId > 3) nextId = 1;
    currentWp = WEAPON_CONFIG[nextId];
    document.getElementById('weapon-id').innerText = currentWp.id;
    fireTimer = 0;
    if(currentWp.id === 3) wp3IdleStartTime = Date.now();
    else document.getElementById('overload-info').style.visibility = 'hidden';
    resetOverload();
}

function resetOverload() { speedMultiplier = 1.0; overloadFrames = 0; document.getElementById('overload-info').style.visibility = 'hidden'; }

function takeDamage() {
    const now = Date.now();
    if (now - player.lastHurtTime > INVULNERABLE_TIME) {
        player.hp--;
        player.lastHurtTime = now;
        document.getElementById('hp-val').innerText = Math.max(0, player.hp);
        if (player.hp <= 0) {
            alert("遊戲結束！");
            location.reload();
        }
    }
}

// 搖桿監聽
canvas.addEventListener('touchstart', e => {
    for(let t of e.changedTouches) {
        if(t.clientX < canvas.width/2) { joyL.active = true; joyL.x1 = joyL.x2 = t.clientX; joyL.y1 = joyL.y2 = t.clientY; joyL.id = t.identifier; }
        else { joyR.active = true; joyR.x1 = joyR.x2 = t.clientX; joyR.y1 = joyR.y2 = t.clientY; joyR.id = t.identifier; }
    }
});

canvas.addEventListener('touchmove', e => {
    for(let t of e.changedTouches) {
        if(joyL.id === t.identifier) { joyL.x2 = t.clientX; joyL.y2 = t.clientY; }
        if(joyR.id === t.identifier) { joyR.x2 = t.clientX; joyR.y2 = t.clientY; }
    }
});

canvas.addEventListener('touchend', e => {
    for(let t of e.changedTouches) {
        if(joyL.id === t.identifier) { joyL.active = false; joyL.id = -1; }
        if(joyR.id === t.identifier) { joyR.active = false; joyR.id = -1; }
    }
});

function spawnEnemy() {
    const side = Math.floor(Math.random() * 4);
    let x, y;
    if(side === 0) { x = Math.random() * canvas.width; y = -30; }
    else if(side === 1) { x = canvas.width + 30; y = Math.random() * canvas.height; }
    else if(side === 2) { x = Math.random() * canvas.width; y = canvas.height + 30; }
    else { x = -30; y = Math.random() * canvas.height; }

    const rand = Math.random() * 100;
    let type;
    if(rand < ENEMY_CONFIG[1].weight) type = ENEMY_CONFIG[1];
    else if(rand < ENEMY_CONFIG[1].weight + ENEMY_CONFIG[2].weight) type = ENEMY_CONFIG[2];
    else type = ENEMY_CONFIG[3];

    enemies.push({ ...type, x, y, lastShootTime: Date.now() });
}

function spawnBullet(angle, offset, speed, isEnemy = false, ex = 0, ey = 0) {
    const b = {
        x: isEnemy ? ex : (player.x + Math.cos(angle + Math.PI/2) * offset),
        y: isEnemy ? ey : (player.y + Math.sin(angle + Math.PI/2) * offset),
        vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed
    };
    if(isEnemy) enemyBullets.push(b); else bullets.push(b);
}

function update() {
    const now = Date.now();
    if(++spawnTimer > ENEMY_CONFIG.spawnRate) { spawnEnemy(); spawnTimer = 0; }

    if(joyL.active) {
        const dx = joyL.x2 - joyL.x1, dy = joyL.y2 - joyL.y1, d = Math.hypot(dx, dy);
        if(d > DEADZONE_LEFT) {
            player.x += (dx/d) * PLAYER_SPEED; player.y += (dy/d) * PLAYER_SPEED;
            if(currentWp.id === 3) wp3IdleStartTime = now;
            idleTriggered = false; resetOverload();
        }
    }

    if(currentWp.id === 3 && !isLocked) {
        const idleSec = (now - wp3IdleStartTime)/1000;
        if(idleSec >= currentWp.overloadTriggerTime) {
            document.getElementById('overload-info').style.visibility = 'visible';
            if(++overloadFrames % 12 === 0) { speedMultiplier += currentWp.overloadIncrement; document.getElementById('speed-bonus').innerText = Math.round((speedMultiplier-1)*100); }
        }
        if(idleSec >= currentWp.ultimateTriggerTime && !idleTriggered) {
            const count = Math.floor((120 / (currentWp.fireInterval/speedMultiplier)) * currentWp.ultimateBulletScale);
            for(let i=0; i<count; i++) spawnBullet((i/count)*Math.PI*2, 0, 8);
            idleTriggered = true; isLocked = true;
            document.getElementById('status-bar').innerText = "系統過熱！";
            setTimeout(() => { isLocked = false; document.getElementById('status-bar').innerText = ""; wp3IdleStartTime = Date.now(); }, currentWp.lockoutDuration * 1000);
            resetOverload();
        }
    }

    if(joyR.active) {
        const dx = joyR.x2 - joyR.x1, dy = joyR.y2 - joyR.y1;
        if(Math.hypot(dx, dy) > DEADZONE_RIGHT) lastAngle = Math.atan2(dy, dx);
    }

    if (!isLocked && --fireTimer <= 0) {
        const interval = currentWp.id === 3 ? (currentWp.fireInterval / speedMultiplier) : currentWp.fireInterval;
        if(currentWp.id === 1) spawnBullet(lastAngle, 0, currentWp.speed);
        else if(currentWp.id === 2) {
            const start = lastAngle - (15 * Math.PI/180);
            for(let i=0; i<15; i++) spawnBullet(start + i*(2*Math.PI/180), 0, currentWp.speed);
        }
        else if(currentWp.id === 3) { spawnBullet(lastAngle, 12, currentWp.speed); spawnBullet(lastAngle, -12, currentWp.speed); }
        fireTimer = interval;
    }

    // 敵人與玩家碰撞判定
    enemies.forEach((en, eIdx) => {
        const dx = player.x - en.x, dy = player.y - en.y, dist = Math.hypot(dx, dy);
        en.x += (dx/dist) * en.speed; en.y += (dy/dist) * en.speed;

        if (dist < en.size + player.size/2) takeDamage();

        if(en.shootInterval > 0 && now - en.lastShootTime > en.shootInterval * 1000) {
            const ang = Math.atan2(dy, dx);
            if(en.id === 2) spawnBullet(ang, 0, en.bulletSpeed, true, en.x, en.y);
            else if(en.id === 3) {
                for(let i=-1; i<=1; i++) spawnBullet(ang + i*15*Math.PI/180, 0, en.bulletSpeed, true, en.x, en.y);
            }
            en.lastShootTime = now;
        }

        bullets.forEach((b, bIdx) => {
            if(Math.hypot(b.x - en.x, b.y - en.y) < en.size) {
                en.hp--; bullets.splice(bIdx, 1);
                if(en.hp <= 0) enemies.splice(eIdx, 1);
            }
        });
    });

    // 敵人子彈擊中玩家判定
    enemyBullets.forEach((eb, ebIdx) => {
        if (Math.hypot(eb.x - player.x, eb.y - player.y) < player.size/2) {
            takeDamage();
            enemyBullets.splice(ebIdx, 1);
        }
    });

    [bullets, enemyBullets].forEach(arr => {
        for(let i=arr.length-1; i>=0; i--) {
            arr[i].x += arr[i].vx; arr[i].y += arr[i].vy;
            if(arr[i].x<0 || arr[i].x>canvas.width || arr[i].y<0 || arr[i].y>canvas.height) arr.splice(i, 1);
        }
    });

    player.x = Math.max(20, Math.min(canvas.width-20, player.x));
    player.y = Math.max(20, Math.min(canvas.height-20, player.y));
}

function draw() {
    ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0,0,canvas.width,canvas.height);
    
    enemies.forEach(en => {
        ctx.fillStyle = en.color;
        ctx.beginPath(); ctx.arc(en.x, en.y, en.size, 0, 7); ctx.fill();
    });

    // 繪製玩家 (無敵時間會閃爍)
    const isInvul = (Date.now() - player.lastHurtTime < INVULNERABLE_TIME);
    if (!isInvul || Math.floor(Date.now()/50) % 2) {
        let pColor = isLocked ? '#444' : (currentWp.id === 3 && speedMultiplier > 1.3 ? '#ff3300' : currentWp.color);
        ctx.fillStyle = pColor; ctx.shadowBlur = isLocked ? 0 : 15; ctx.shadowColor = pColor;
        ctx.fillRect(player.x - player.size/2, player.y - player.size/2, player.size, player.size);
        ctx.shadowBlur = 0;
    }

    ctx.fillStyle = '#fff'; bullets.forEach(b => ctx.fillRect(b.x-2, b.y-2, 4, 4));
    ctx.fillStyle = '#f00'; enemyBullets.forEach(b => ctx.fillRect(b.x-2, b.y-2, 4, 4));

    if(joyL.active) drawJoy(joyL, '#00ccff');
    if(joyR.active) drawJoy(joyR, '#ff3300');

    update();
    requestAnimationFrame(draw);
}

function drawJoy(j, c) {
    ctx.beginPath(); ctx.arc(j.x1, j.y1, 50, 0, 7); ctx.strokeStyle = c+'33'; ctx.lineWidth=2; ctx.stroke();
    ctx.beginPath(); ctx.arc(j.x2, j.y2, 25, 0, 7); ctx.fillStyle = c+'66'; ctx.fill();
}

draw();
</script>
</body>
</html>
