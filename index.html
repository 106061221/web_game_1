<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>工具裝箱挑戰 - 完美連通版</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; background: #2c3e50; font-family: sans-serif; touch-action: none; }
        .controls { margin-bottom: 15px; display: flex; gap: 10px; }
        button { padding: 12px 24px; font-size: 16px; font-weight: bold; cursor: pointer; background: #27ae60; color: white; border: none; border-radius: 8px; box-shadow: 0 4px #1e8449; }
        button:active { box-shadow: 0 0px #1e8449; transform: translateY(4px); }
        canvas { background: #ecf0f1; border: 5px solid #34495e; border-radius: 4px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
    </style>
</head>
<body>

<div class="controls">
    <button onclick="showSolution()">公佈答案</button>
    <button style="background:#e67e22; box-shadow:0 4px #d35400" onclick="location.reload()">重新開始</button>
</div>
<canvas id="gameCanvas" width="400" height="650"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const GRID_SIZE = 42;
const BOARD_POS = { x: 33, y: 40 };

// 經過嚴格校對的連通性矩陣 (8x8)
const layout = [
    ['S','S','S','S','S','S','S','S'],
    ['H','H','H','B','B','B','B','B'],
    ['P','H','P','P','D','D','D','B'],
    ['P','H','P','R','R','R','D','B'],
    ['P','P','P','R','K','K','D','B'],
    ['W','W','W','R','K','K','D','B'],
    ['W','W','W','R','K','K','K','K'],
    ['W','W','W','R','K','K','K','K']
];

const colors = {
    'S': '#95A5A6', 'H': '#E74C3C', 'B': '#273c75',
    'P': '#1ABC9C', 'D': '#3498DB', 'R': '#8E44AD',
    'K': '#D35400', 'W': '#F1C40F'
};

function parseLayout(layout) {
    let tempPieces = {};
    for(let y=0; y<8; y++) {
        for(let x=0; x<8; x++) {
            let char = layout[y][x];
            if(!tempPieces[char]) {
                tempPieces[char] = { 
                    name: char, color: colors[char], 
                    sol: {x: x, y: y}, shape: [],
                    x: Math.random()*280, y: 420 + Math.random()*120 
                };
            }
            tempPieces[char].shape.push({
                x: x - tempPieces[char].sol.x,
                y: y - tempPieces[char].sol.y
            });
        }
    }
    return Object.values(tempPieces);
}

let pieces = parseLayout(layout);
let activePiece = null;
let offset = { x: 0, y: 0 };

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 繪製箱子
    ctx.fillStyle = "#fff";
    ctx.fillRect(BOARD_POS.x, BOARD_POS.y, 8*GRID_SIZE, 8*GRID_SIZE);
    ctx.strokeStyle = '#bdc3c7';
    for(let i=0; i<=8; i++) {
        ctx.beginPath(); ctx.moveTo(BOARD_POS.x, BOARD_POS.y + i*GRID_SIZE); ctx.lineTo(BOARD_POS.x + 8*GRID_SIZE, BOARD_POS.y + i*GRID_SIZE); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(BOARD_POS.x + i*GRID_SIZE, BOARD_POS.y); ctx.lineTo(BOARD_POS.x + i*GRID_SIZE, BOARD_POS.y + 8*GRID_SIZE); ctx.stroke();
    }

    // 繪製工具
    pieces.forEach(p => {
        if (p === activePiece) return;
        drawPiece(p);
    });
    if (activePiece) drawPiece(activePiece);

    requestAnimationFrame(draw);
}

function drawPiece(p) {
    ctx.fillStyle = p.color;
    ctx.strokeStyle = "#2c3e50";
    ctx.lineWidth = 2;
    p.shape.forEach(cell => {
        const px = p.x + cell.x*GRID_SIZE;
        const py = p.y + cell.y*GRID_SIZE;
        ctx.fillRect(px, py, GRID_SIZE, GRID_SIZE);
        ctx.strokeRect(px, py, GRID_SIZE, GRID_SIZE);
    });
}

function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: cx - rect.left, y: cy - rect.top };
}

canvas.addEventListener('mousedown', e => {
    const pos = getPos(e);
    for (let i = pieces.length - 1; i >= 0; i--) {
        const p = pieces[i];
        for (let cell of p.shape) {
            const cx = p.x + cell.x*GRID_SIZE;
            const cy = p.y + cell.y*GRID_SIZE;
            if (pos.x >= cx && pos.x <= cx + GRID_SIZE && pos.y >= cy && pos.y <= cy + GRID_SIZE) {
                activePiece = p;
                offset.x = pos.x - p.x; offset.y = pos.y - p.y;
                return;
            }
        }
    }
});

window.addEventListener('mousemove', e => {
    if (!activePiece) return;
    if (e.cancelable) e.preventDefault();
    const pos = getPos(e);
    activePiece.x = pos.x - offset.x; activePiece.y = pos.y - offset.y;
});

window.addEventListener('mouseup', () => {
    if (!activePiece) return;
    if (activePiece.x > BOARD_POS.x - GRID_SIZE && activePiece.x < BOARD_POS.x + 8 * GRID_SIZE &&
        activePiece.y > BOARD_POS.y - GRID_SIZE && activePiece.y < BOARD_POS.y + 8 * GRID_SIZE) {
        activePiece.x = Math.round((activePiece.x - BOARD_POS.x)/GRID_SIZE)*GRID_SIZE + BOARD_POS.x;
        activePiece.y = Math.round((activePiece.y - BOARD_POS.y)/GRID_SIZE)*GRID_SIZE + BOARD_POS.y;
    }
    checkWin();
    activePiece = null;
});

function checkWin() {
    const win = pieces.every(p => 
        Math.abs(p.x - (BOARD_POS.x + p.sol.x * GRID_SIZE)) < 1 &&
        Math.abs(p.y - (BOARD_POS.y + p.sol.y * GRID_SIZE)) < 1
    );
    if(win) setTimeout(() => alert("過關！工具已完美裝入箱子！"), 200);
}

function showSolution() {
    pieces.forEach(p => {
        p.x = BOARD_POS.x + p.sol.x * GRID_SIZE;
        p.y = BOARD_POS.y + p.sol.y * GRID_SIZE;
    });
}

// 觸控支援
canvas.addEventListener('touchstart', e => {
    const mouseEvent = new MouseEvent("mousedown", { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
    canvas.dispatchEvent(mouseEvent);
}, {passive: false});
window.addEventListener('touchmove', e => {
    const mouseEvent = new MouseEvent("mousemove", { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
    window.dispatchEvent(mouseEvent);
}, {passive: false});
window.addEventListener('touchend', () => {
    window.dispatchEvent(new MouseEvent("mouseup", {}));
});

draw();
</script>
</body>
</html>
