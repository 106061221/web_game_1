<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>生存射擊 - 物理公式與敵人邏輯修正版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui-left { position: absolute; top: 20px; left: 30px; color: #fff; pointer-events: none; z-index: 10; }
        #ui-right { position: absolute; top: 20px; right: 30px; text-align: right; color: #fff; pointer-events: none; z-index: 10; }
        .weapon-tag { font-weight: bold; font-size: 22px; color: #00ffcc; }
        #hp-bar { font-size: 20px; color: #ff5555; margin-top: 5px; font-weight: bold; }
        #status-bar { position: absolute; top: 25px; left: 50%; transform: translateX(-50%); color: #ff3300; font-size: 18px; font-weight: bold; pointer-events: none; }
        
        #weapon-btn {
            position: absolute; right: 40px; bottom: 180px; width: 75px; height: 75px;
            background: rgba(255, 255, 255, 0.1); border: 2px solid #00ffcc;
            border-radius: 50%; color: #00ffcc; display: flex; align-items: center;
            justify-content: center; font-weight: bold; font-size: 14px; z-index: 20;
            backdrop-filter: blur(3px); -webkit-user-select: none;
        }
        #tp-btn {
            position: absolute; right: 130px; bottom: 80px; width: 75px; height: 75px;
            background: rgba(0, 255, 0, 0.1); border: 2px solid #00ff00;
            border-radius: 50%; color: #00ff00; display: flex; align-items: center;
            justify-content: center; font-weight: bold; font-size: 14px; z-index: 20;
            backdrop-filter: blur(3px); -webkit-user-select: none;
        }
        #tp-cd-overlay { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(0, 0, 0, 0.6); border-radius: 50%; }
    </style>
</head>
<body>
    <div id="ui-left">
        <div id="hp-bar">HP: <span id="hp-val">30</span></div>
        <div id="overload-info" style="color:#ff3300; font-weight:bold; visibility:hidden;">超載攻速: +<span id="speed-bonus">0</span>%</div>
    </div>
    <div id="status-bar"></div>
    <div id="ui-right">
        <div class="weapon-tag">武器: <span id="weapon-id">1</span></div>
        <div class="stat-label" style="color:#ffd700">SCORE: <span id="score-val">0</span></div>
        <div class="stat-label" style="color:#ffd700">LV: <span id="level-val">0</span></div>
    </div>

    <div id="weapon-btn">換武器</div>
    <div id="tp-btn">瞬移<div id="tp-cd-overlay"></div></div>
    <canvas id="gameCanvas"></canvas>

<script>
// --- 核心配置 ---
const BASE_FIRE_INTERVAL = 8;
const WEAPON_CONFIG = {
    1: { id: 1, intervalMult: 1.0, speed: 15, color: '#fff' },
    2: { id: 2, intervalMult: 15.0, speed: 15, color: '#ffcc00' },
    3: { id: 3, intervalMult: 2.2, speed: 15, color: '#00ccff', 
         overloadTriggerTime: 0.6, ultimateTriggerTime: 3.6, ultimateDuration: 1.0 }
};
Object.values(WEAPON_CONFIG).forEach(wp => wp.fireInterval = wp.intervalMult * BASE_FIRE_INTERVAL);

const ENEMY_CONFIG = {
    spawnRateBase: 80,
    1: { id: 1, speed: 0.2, hpBase: 2, size: 15, color: '#888888', shootInterval: 0, weight: 68.5, score: 50 },
    2: { id: 2, speed: 0.2, hpBase: 4, size: 25, color: '#ff4444', shootInterval: 4, bulletSpeed: 0.6, weight: 15, score: 100 },
    3: { id: 3, speed: 0.2, hpBase: 4, size: 25, color: '#aa00ff', shootInterval: 13, bulletSpeed: 0.6, weight: 15, score: 100 },
    4: { id: 4, speed: 0.2, hpBase: 40, size: 40, color: '#FFD700', shootInterval: 10, bulletSpeed: 0.6, weight: 1.5, score: 500, dropRate: 1.0 }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
function handleResize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', handleResize);
handleResize();

let player = { x: canvas.width/2, y: canvas.height/2, hp: 30, maxHp: 30, size: 21, lastHurtTime: 0 };
let bullets = [], enemyBullets = [], enemies = [], medkits = [];
let currentWp = WEAPON_CONFIG[1];
let fireTimer = 0, spawnTimer = 0, score = 0, difficultyLevel = 0, lastAngle = 0;
let wp3IdleStartTime = Date.now(), speedMultiplier = 1.0, isLocked = false, overloadFrames = 0;

// 搖桿與瞬移
let joyL = { active: false, x1: 0, y1: 0, x2: 0, y2: 0, id: -1 };
let joyR = { active: false, x1: 0, y1: 0, x2: 0, y2: 0, id: -1 };
let joyT = { active: false, x1: 0, y1: 0, x2: 0, y2: 0, id: -1 };
let tpTarget = { x: 0, y: 0 }, tpCooldown = 0;
const TP_COOLDOWN_TIME = 3000;

function takeDamage() {
    const now = Date.now();
    if (now - player.lastHurtTime > 250) {
        player.hp--; player.lastHurtTime = now;
        document.getElementById('hp-val').innerText = Math.max(0, player.hp);
        if (player.hp <= 0) { alert("遊戲結束！"); location.reload(); }
    }
}

// --- 事件處理 ---
document.getElementById('weapon-btn').addEventListener('touchstart', e => {
    e.preventDefault();
    let nextId = currentWp.id + 1; if(nextId > 3) nextId = 1;
    currentWp = WEAPON_CONFIG[nextId];
    document.getElementById('weapon-id').innerText = currentWp.id;
    // 換武器延遲：設為當前應有的射擊間隔
    const diffBonus = (1 + difficultyLevel * 0.05);
    fireTimer = currentWp.fireInterval / diffBonus;
    speedMultiplier = 1.0; wp3IdleStartTime = Date.now();
});

const tpBtn = document.getElementById('tp-btn');
tpBtn.addEventListener('touchstart', e => {
    e.preventDefault(); if(tpCooldown > 0) return;
    const t = e.changedTouches[0]; joyT.active = true; joyT.id = t.identifier;
    joyT.x1 = joyT.x2 = t.clientX; joyT.y1 = joyT.y2 = t.clientY;
    tpTarget = { x: player.x, y: player.y };
}, {passive: false});

canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    for(let t of e.changedTouches) {
        if(t.clientX < canvas.width/2) { joyL.active = true; joyL.x1 = joyL.x2 = t.clientX; joyL.y1 = joyL.y2 = t.clientY; joyL.id = t.identifier; }
        else { joyR.active = true; joyR.x1 = joyR.x2 = t.clientX; joyR.y1 = joyR.y2 = t.clientY; joyR.id = t.identifier; }
    }
}, {passive: false});

window.addEventListener('touchmove', e => {
    e.preventDefault();
    for(let t of e.changedTouches) {
        if(joyL.id === t.identifier) { joyL.x2 = t.clientX; joyL.y2 = t.clientY; }
        if(joyR.id === t.identifier) { joyR.x2 = t.clientX; joyR.y2 = t.clientY; }
        if(joyT.id === t.identifier) {
            joyT.x2 = t.clientX; joyT.y2 = t.clientY;
            tpTarget.x = player.x + (joyT.x2 - joyT.x1) * 3.5;
            tpTarget.y = player.y + (joyT.y2 - joyT.y1) * 3.5;
        }
    }
}, {passive: false});

window.addEventListener('touchend', e => {
    for(let t of e.changedTouches) {
        if(joyL.id === t.identifier) { joyL.active = false; joyL.id = -1; }
        if(joyR.id === t.identifier) { joyR.active = false; joyR.id = -1; }
        if(joyT.id === t.identifier) {
            player.x = Math.max(20, Math.min(canvas.width-20, tpTarget.x));
            player.y = Math.max(20, Math.min(canvas.height-20, tpTarget.y));
            tpCooldown = TP_COOLDOWN_TIME; joyT.active = false; joyT.id = -1;
        }
    }
}, {passive: false});

function spawnBullet(angle, offset, speed, isEnemy = false, ex = 0, ey = 0) {
    const b = { 
        x: isEnemy ? ex : (player.x + Math.cos(angle + Math.PI/2) * offset), 
        y: isEnemy ? ey : (player.y + Math.sin(angle + Math.PI/2) * offset), 
        vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed 
    };
    if(isEnemy) enemyBullets.push(b); else bullets.push(b);
}

function update() {
    const now = Date.now();
    const diffBonus = (1 + difficultyLevel * 0.05);
    difficultyLevel = Math.floor(score / 1000);
    document.getElementById('level-val').innerText = difficultyLevel;

    if(tpCooldown > 0) { tpCooldown -= 16; document.getElementById('tp-cd-overlay').style.height = (tpCooldown/TP_COOLDOWN_TIME)*100 + "%"; }

    // 敵人生成
    if(++spawnTimer > (ENEMY_CONFIG.spawnRateBase / (1 + difficultyLevel * 0.01))) {
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if(side === 0) { x = Math.random() * canvas.width; y = -50; }
        else if(side === 1) { x = canvas.width + 50; y = Math.random() * canvas.height; }
        else if(side === 2) { x = Math.random() * canvas.width; y = canvas.height + 50; }
        else { x = -50; y = Math.random() * canvas.height; }
        const rand = Math.random() * 100;
        let type = (rand < 68.5) ? ENEMY_CONFIG[1] : (rand < 83.5) ? ENEMY_CONFIG[2] : (rand < 98.5) ? ENEMY_CONFIG[3] : ENEMY_CONFIG[4];
        enemies.push({ ...type, x, y, hp: type.hpBase * diffBonus, lastShootTime: now, lastHitTime: 0 });
        spawnTimer = 0; 
    }

    if(joyL.active) {
        const dx = joyL.x2 - joyL.x1, dy = joyL.y2 - joyL.y1, d = Math.hypot(dx, dy);
        if(d > 2) { player.x += (dx/d) * 1.5; player.y += (dy/d) * 1.5; if(currentWp.id === 3 && !isLocked) { speedMultiplier = 1.0; wp3IdleStartTime = now; } }
    }

    // 武器 3 物理大招公式
    if(currentWp.id === 3 && !isLocked) {
        const idleSec = (now - wp3IdleStartTime) / 1000;
        if(idleSec >= currentWp.overloadTriggerTime) {
            document.getElementById('overload-info').style.visibility = 'visible';
            if(++overloadFrames % 12 === 0) { speedMultiplier += 0.1; document.getElementById('speed-bonus').innerText = Math.round((speedMultiplier-1)*100); }
        } else { document.getElementById('overload-info').style.visibility = 'hidden'; }
        if(idleSec >= currentWp.ultimateTriggerTime) {
            // N = (1 / 當前間隔 * 爆發秒數)
            const currentInterval = (currentWp.fireInterval / speedMultiplier) / diffBonus;
            const bulletCount = Math.floor((currentWp.ultimateDuration * 60) / currentInterval);
            for(let i=0; i < bulletCount; i++) spawnBullet((i/bulletCount) * Math.PI * 2, 0, 8);
            isLocked = true; document.getElementById('status-bar').innerText = "系統過熱！";
            setTimeout(() => { isLocked = false; document.getElementById('status-bar').innerText = ""; speedMultiplier = 1.0; wp3IdleStartTime = Date.now(); }, 2000);
        }
    }

    if(joyR.active) lastAngle = Math.atan2(joyR.y2 - joyR.y1, joyR.x2 - joyR.x1);

    if (!isLocked && --fireTimer <= 0) {
        const interval = (currentWp.id === 3 ? (currentWp.fireInterval / speedMultiplier) : currentWp.fireInterval) / diffBonus;
        if(currentWp.id === 1) spawnBullet(lastAngle, 0, currentWp.speed);
        else if(currentWp.id === 2) for(let i=0; i<15; i++) spawnBullet(lastAngle - (15*Math.PI/180) + i*(2*Math.PI/180), 0, currentWp.speed);
        else if(currentWp.id === 3) { spawnBullet(lastAngle, 12, currentWp.speed); spawnBullet(lastAngle, -12, currentWp.speed); }
        fireTimer = interval;
    }

    // 敵人移動與射擊 (恢復正常)
    for (let eIdx = enemies.length - 1; eIdx >= 0; eIdx--) {
        let en = enemies[eIdx]; const dx = player.x - en.x, dy = player.y - en.y, dist = Math.hypot(dx, dy);
        en.x += (dx/dist) * en.speed * diffBonus; en.y += (dy/dist) * en.speed * diffBonus;
        if (dist < en.size + player.size/2) takeDamage();
        
        if (en.shootInterval > 0 && now - en.lastShootTime > (1000 / en.shootInterval) / diffBonus) {
            const angle = Math.atan2(player.y - en.y, player.x - en.x);
            if (en.id === 4) { for(let i=-1; i<=1; i++) spawnBullet(angle + i*0.3, 0, en.bulletSpeed, true, en.x, en.y); }
            else { spawnBullet(angle, 0, en.bulletSpeed, true, en.x, en.y); }
            en.lastShootTime = now;
        }

        for (let bIdx = bullets.length - 1; bIdx >= 0; bIdx--) {
            if(Math.hypot(bullets[bIdx].x - en.x, bullets[bIdx].y - en.y) < en.size + 5) {
                en.hp -= 1; en.lastHitTime = now; bullets.splice(bIdx, 1);
                if(en.hp <= 0) { 
                    score += en.score; if(en.dropRate && Math.random() < en.dropRate) medkits.push({x: en.x, y: en.y});
                    document.getElementById('score-val').innerText = score; enemies.splice(eIdx, 1); break; 
                }
            }
        }
    }

    // 子彈位移
    [bullets, enemyBullets].forEach((arr, isEnemyArr) => {
        for(let i=arr.length-1; i>=0; i--) {
            const b = arr[i]; b.x += b.vx; b.y += b.vy;
            if(isEnemyArr === 1 && Math.hypot(b.x - player.x, b.y - player.y) < player.size/2 + 5) { takeDamage(); arr.splice(i, 1); continue; }
            if(b.x<0 || b.x>canvas.width || b.y<0 || b.y>canvas.height) arr.splice(i, 1);
        }
    });
    
    medkits.forEach((m, i) => { if(Math.hypot(m.x - player.x, m.y - player.y) < player.size) { player.hp = Math.min(30, player.hp + 10); document.getElementById('hp-val').innerText = player.hp; medkits.splice(i, 1); } });
    player.x = Math.max(20, Math.min(canvas.width-20, player.x)); player.y = Math.max(20, Math.min(canvas.height-20, player.y));
}

function draw() {
    const now = Date.now();
    ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0,0,canvas.width,canvas.height);
    medkits.forEach(m => { ctx.fillStyle = (Math.floor(now/200)%2) ? '#00ff00' : '#fff'; ctx.fillRect(m.x-8, m.y-2, 16, 4); ctx.fillRect(m.x-2, m.y-8, 4, 16); });
    enemies.forEach(en => { ctx.fillStyle = (now - en.lastHitTime < 50) ? '#fff' : en.color
