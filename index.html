<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>AI æˆ°æ©Ÿå½ˆå¹•éŠæˆ² (V69.2)</title>
    <style>
        /* æ¨£å¼ä¿æŒä¸è®Š */
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh; 
            margin: 0;
            background-color: #111;
            color: white;
            font-family: 'Courier New', monospace;
        }
        #top-info { 
            width: 750px; 
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        #hp-display { font-size: 1.5em; color: lime; }
        #score-board { font-size: 1.5em; }
        #dps-display { font-size: 1.5em; color: orange; }
        #weapon-status {
            font-size: 1.2em;
            color: #ccc;
            text-align: center;
            margin-bottom: 10px;
        }
        #game-container {
            width: 500px;
            height: 440px;
	    /* ğŸ¯ é—œéµä¿®æ­£ 2ï¼šç¢ºä¿å¯¬é«˜ä¸æœƒè¢«å£“ç¸®ï¼Œç¶­æŒå‰›æ€§ */
   	    min-width: 500px;
   	    min-height: 440px;

            background-color: #000;
            border: 2px solid #555;
            position: relative;
            overflow: hidden;
            outline: none; 
            cursor: crosshair; 
        }
        #player {
            position: absolute;
            width: 18px; 
            height: 18px; 
            background-color: cyan;
            border-radius: 50%; 
            bottom: 291px; 
            left: 241px; 
            transition: background-color 0.1s, box-shadow 0.2s; 
            z-index: 10; 
        }
        .player-hit { 
            opacity: 0.5;
            transition: opacity 0.05s ease-in-out;
        }
        /* Dash ready visual */
        .player-dash-ready {
            box-shadow: 0 0 6px 2px rgba(255, 255, 255, 0.35), 0 0 14px 4px rgba(0, 180, 255, 0.45);
            animation: dash-ready-pulse 1.8s infinite ease-in-out;
        }
        @keyframes dash-ready-pulse {
            0% { box-shadow: 0 0 5px 2px rgba(255,255,255,0.25), 0 0 10px 3px rgba(0,180,255,0.35); }
            50% { box-shadow: 0 0 8px 3px rgba(255,255,255,0.45), 0 0 18px 5px rgba(0,180,255,0.6); }
            100% { box-shadow: 0 0 5px 2px rgba(255,255,255,0.25), 0 0 10px 3px rgba(0,180,255,0.35); }
        }
        
        #continuous-sword-blade {
            position: absolute;
            width: 35px; 
            height: 130px; 
            clip-path: polygon(25% 100%, 75% 100%, 50% 0%); 
            background: linear-gradient(to top, rgba(0, 100, 255, 1) 10%, rgba(50, 200, 255, 1) 50%, rgba(255, 255, 255, 1) 90%);
            box-shadow: 0 0 10px 5px rgba(0, 191, 255, 0.9), 0 0 25px 10px rgba(0, 50, 200, 0.6), inset 0 0 5px 2px rgba(255, 255, 255, 1);
            border-radius: 2px; 
            transform-origin: bottom center; 
            z-index: 9;
            pointer-events: none;
            opacity: 1;
            transition: left 0.01s linear, top 0.01s linear, transform 0.01s linear; 
            display: none; 
            animation: blue-flame-flicker 0.2s infinite alternate; 
        }
        @keyframes blue-flame-flicker {
            from { opacity: 0.9; transform: scaleY(1) rotate(var(--current-rotation)); }
            to { opacity: 1.0; transform: scaleY(1.02) rotate(var(--current-rotation)); }
        }

        #static-field-aura {
            position: absolute;
            border: 2px solid rgba(138, 43, 226, 0.9); 
            border-radius: 50%;
            background-color: rgba(128, 0, 128, 0.05); 
            pointer-events: none; 
            z-index: 5;
            transition: box-shadow 0.15s ease-out, transform 0.15s ease-out;
            box-shadow: 0 0 10px 5px rgba(138, 43, 226, 0.5), inset 0 0 10px 5px rgba(138, 43, 226, 0.4); 
            animation: pulse-base 2s infinite alternate; 
        }
        .static-field-pulse {
            box-shadow: 0 0 20px 10px rgba(255, 255, 255, 0.8), 0 0 40px 20px rgba(255, 0, 0, 0.6), inset 0 0 15px 7px rgba(138, 43, 226, 0.8);
            transform: scale(1.03); 
        }
        @keyframes pulse-base { from { opacity: 0.85; } to { opacity: 1.0; } }

         .sword-hit-effect {
            box-shadow: 0 0 15px 10px rgba(255, 255, 255, 1), 0 0 40px 20px rgba(255, 50, 0, 0.8), inset 0 0 10px 5px rgba(255, 255, 255, 1);
            transition: all 0.05s ease-out; 
        }


	/* æ–°å¢é›·å°„æ¨£å¼ */
	.laser-beam {
    		position: absolute;
    		height: 14px; /* é›·å°„å¯¬åº¦ */
    		background: white;
    		transform-origin: center left; /* å¾å·¦å´æ—‹è½‰ */
    		opacity: 1;
    		z-index: 20;
    		box-shadow: 0 0 10px 4px cyan, 0 0 20px 8px blue;
    		pointer-events: none;
    		border-radius: 4px;
	}
	/* è“„åŠ›æ™‚ç©å®¶çš„ç™¼å…‰æ•ˆæœ */
	//.player-charging {
    	//	box-shadow: 0 0 15px 5px cyan, inset 0 0 10px white !important;
    	//	background-color: #00FFFF !important;
	//}
	
	
	.player-charging {
    	/* ä½¿ç”¨ Electric Violet (#BF00FF) ä½œç‚ºç©å®¶é¡è‰² */
    		background-color: #E0FFFF !important; 

    	/* é‚Šæ¡†ç™¼å…‰ä½¿ç”¨æ›´æ·±çš„ç´«è‰²å’Œæ´‹ç´…è‰²æ··åˆï¼Œç‡Ÿé€ èƒ½é‡æ„Ÿ */
    		box-shadow: 
        	0 0 15px 5px #00FFFF,        /* ä¸»è¦å…‰æšˆï¼šé›»å…‰ç´« */
        	0 0 20wpx 8px #00BFFF,        /* æ¬¡è¦å…‰æšˆï¼šæ´‹ç´… */
        	//inset 0 0 10px white !important; /* ä¸­å¿ƒäº®é» */
	}

	.laser-charging-alt {
    		background-color: #E0FFFF !important; /* å¾ˆç™½çš„è—è‰² */
    		//box-shadow: 
        	//0 0 15px 5px #00FFFF,         /* é’è‰²å…‰æšˆ */
       		//0 0 25px 10px #00BFFF,        
        	//inset 0 0 10px white !important; 
	}
	
	.laser-charging-alt2 {
    		background-color: #E0FFFF !important; /* å¾ˆç™½çš„è—è‰² */
    		box-shadow: 
        	0 0 15px 5px #00FFFF,         /* é’è‰²å…‰æšˆ */
       		0 0 25px 10px #00BFFF,        
        	inset 0 0 10px white !important; 
	}
	
	
	.player-overload {
    		filter: brightness(1.8) drop-shadow(0 0 10px orange) !important;
    		box-shadow: 0 0 20px orange !important;
	}
	
	
	
	



        .bullet {
            position: absolute;
            width: 4px; height: 4px;
            background-color: white; 
            border-radius: 50%;
            z-index: 9;
        }
        .enemy, .griefer-enemy { 
            position: absolute;
            width: 30px; height: 30px;
            background-color: red;
            border-radius: 5px;
            box-shadow: 0 0 5px orange;
            display: flex; justify-content: center; align-items: center;
            font-size: 10px; font-weight: bold; color: white;
            z-index: 8;
        }
        .griefer-enemy { background-color: gray; box-shadow: 0 0 5px #ccc; }
        .rare-enemy {
             position: absolute;
            width: 50px; height: 50px;
            background-color: gold;
            border-radius: 10px;
            box-shadow: 0 0 10px yellow;
            display: flex; justify-content: center; align-items: center;
            font-size: 12px; font-weight: bold; color: black;
            border: 2px solid white;
            z-index: 8;
        }
        /* Boss æ¨£å¼ */
        .boss-enemy {
            position: absolute;
            width: 100px; height: 100px;
            border-radius: 15px;
            box-shadow: 0 0 20px 10px rgba(255, 0, 0, 0.8), inset 0 0 15px white;
            display: flex; justify-content: center; align-items: center;
            font-size: 16px; font-weight: bold; color: white;
            z-index: 10; 
            border: 3px solid red;
            transition: transform 0.5s ease-out; 
        }

        .enemy-bullet { 
            position: absolute;
            width: 6px; height: 6px;
            background-color: yellow; 
            border-radius: 50%;
            z-index: 7;
        }
        .heart-drop {
            position: absolute;
            width: 15px; height: 15px;
            background-color: pink;
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 10px; color: darkred;
            z-index: 6;
        }
        
        #start-message, #game-over-message, #pause-message { 
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px; color: lime;
            text-shadow: 0 0 5px lime;
            z-index: 11;
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
        }
        #game-over-message { color: red; text-shadow: 0 0 10px red; display: none; }
        #pause-message { color: yellow; text-shadow: 0 0 5px yellow; display: none; }
    </style>
</head>
<body>

    <h1>å¤ªç©ºæˆ°æ©Ÿå½ˆå¹• - ç«¶æŠ€å ´æ¨¡å¼ </h1>
    <div id="top-info">
        <div id="hp-display">HP: <span id="player-hp">30</span></div>
        <div id="score-board">åˆ†æ•¸: <span id="score">0</span></div>
        <div id="dps-display">DPS: <span id="current-dps">0.0</span></div>
    </div>
    
    <div id="weapon-status">æ­¦å™¨: <span id="weapon-name">å–®ç®¡æ©Ÿæ§</span> (<span id="fire-rate-info">85ms</span>) | ç¬ç§»: **ç©ºç™½éµ** (3s CD)</div>
    
    <div id="game-container" tabindex="0"> 
        <div id="continuous-sword-blade"></div> 
        <div id="static-field-aura"></div> 
        <div id="player"></div>
        <div id="start-message">
            æŒ‰ **WASD/æ–¹å‘éµ** é–‹å§‹éŠæˆ²
            <br>
            <span style="font-size:14px; color:#aaa;">(E éµæˆ–æ»‘é¼ æ»¾è¼ªåˆ‡æ›æ­¦å™¨ / ç©ºç™½éµç¬ç§» / ESC æš«åœ)</span>
        </div>
        
        <div id="pause-message">
            **éŠæˆ²æš«åœ (PAUSED)**
            <br>
            <span style="font-size:14px; color:#ccc;">å†æ¬¡æŒ‰ä¸‹ ESC ç¹¼çºŒéŠæˆ²</span>
        </div>
        
        <div id="game-over-message">
            éŠæˆ²çµæŸï¼
            <div id="final-score"></div>
            <button onclick="window.location.reload()" style="padding: 10px 20px; margin-top: 15px;">é‡æ–°é–‹å§‹</button>
        </div>
    </div>
    
    <p>ä½¿ç”¨ WASD/æ–¹å‘éµ ç§»å‹•ï¼Œæ»‘é¼ ç„æº–ã€‚</p>

    <script>
        // *** æ ¸å¿ƒåƒæ•¸ ***
        const MAX_PLAYER_HP = 30.0; 
        const ENEMY_BULLET_SPEED = 0.3; 
        const BOSS_BULLET_SPEED = 1.5; // Boss å­å½ˆé€Ÿåº¦
        const ENEMY_BULLET_DAMAGE = 1.0; 
        const INITIAL_FIRE_RATE_MODIFIER = 2.2533; 
        const BASE_SINGLE_SHOT_RATE = 50 * INITIAL_FIRE_RATE_MODIFIER; 
        const PLAYER_HIT_COOLDOWN = 250; 

        // DPS åƒæ•¸
        const DPS_UPDATE_INTERVAL = 500; 
        const DPS_WINDOW_SIZE = 3000;    








// --- æƒ¡ç«é‡æ©Ÿæ§ (HMG) éè¼‰å°ˆå±¬åƒæ•¸ ---
const HMG_OVERLOAD_TRIGGER_MS = 500;   // 0.5ç§’é€²å…¥éè¼‰
const HMG_OVERLOAD_SPREAD = 2.5;         // éè¼‰æ•£åº¦ 5åº¦
const HMG_RAMP_INTERVAL = 200;         // 0.2ç§’æˆé•·ä¸€æ¬¡
const HMG_RAMP_RATE = 0.09;            // æ¯æ¬¡å¿« 10%
const HMG_MAX_DURATION = 3200;         // 4ç§’å¤§æ‹›
const HMG_EXPLOSION_BASE_SEC = 2000;   // å¤§æ‹›åŸºæ•¸
const HMG_COOLDOWN_MS = 1300;          // 1ç§’å†·å»






        // éœé›»åŠ›å ´åƒæ•¸ 
        const STATIC_FIELD_RATE = BASE_SINGLE_SHOT_RATE * 3; 
        const STATIC_FIELD_DAMAGE = 1.0; 
        const BASE_STATIC_RANGE = 75;
        const STATIC_FIELD_RANGE = BASE_STATIC_RANGE * 1.035; 

        // è„ˆè¡ç«ç„°åƒæ•¸ 
        const SWORD_BLADE_RATE = BASE_SINGLE_SHOT_RATE * 1.3; 
        const SWORD_BLADE_DAMAGE = 1.0; 
        const SWORD_BLADE_WIDTH = 35; 
        const SWORD_BLADE_HEIGHT = 130; 
        const SWORD_DAMAGE_POINTS = 10; 
        const SWORD_ROTATION_SPEED = 0.5; 
        const SWORD_OFFSET_DISTANCE = 0; 
        
        // éŠæˆ²ä¸­å¿ƒé»åæ¨™
        const GAME_CENTER = { x: 250, y: 300 };
        const PLAYER_MAX_Y_BOUND = 440; 

        // æ•µäººé…ç½®
        const BASE_ENEMY_CONFIGS = [
            { type: 1, baseHp: 6.0, score: 100, color: 'red', className: 'enemy' },
            { type: 2, baseHp: 6.0, score: 100, color: 'purple', className: 'enemy' },
            { type: 3, baseHp: 60.0, score: 500, color: 'gold', className: 'rare-enemy' },
            { type: 4, baseHp: 3.0, score: 100, color: 'gray', className: 'griefer-enemy' }
        ];
        
        // --- Boss è§¸ç™¼åƒæ•¸ ---
        const BOSS_PREP_DURATION = 5000; 
        
        // Boss 1 åƒæ•¸
        const BOSS1_COOLDOWN_INTERVAL = 2000; 
        const BOSS1_BURST_COUNT = 5; 
        const BOSS1_BURST_INTERVAL = 500; 
        const BOSS1_SPREAD_SHOTS = 6; 
        
        // Boss 2 åƒæ•¸
        const BOSS2_PHASE_A_WAVES = 10;
        const BOSS2_PHASE_A_INTERVAL = 200;
        const BOSS2_PHASE_B_SHOTS = 30;
        const BOSS2_PHASE_B_INTERVAL = 50;
        const BOSS2_REST_TIME = 100; // 1ç§’ä¼‘æ¯
        


	// ==========================================
        // *** æ–°å¢ï¼šBoss 3 (Type 101) åƒæ•¸è¨­å®š ***
        // ==========================================
        const BOSS3_TRIGGER_SCORE = 80000;      // å‡ºç¾åˆ†æ•¸
        const BOSS3_Y_POS = 60;                 // åœç•™åœ¨ Y=60

        // --- æ¨¡å¼ 1: å…¨æ–¹ä½æ—‹è½‰å½ˆå¹• (Spin) ---
        const BOSS3_P1_INTERVAL = 10;           // ç™¼å°„é–“éš” (ms)
        const BOSS3_P1_ROTATION_SEC = 0.45;      // è½‰ä¸€åœˆéœ€è¦å¹¾ç§’
        const BOSS3_P1_TOTAL_LOOPS = 1.5;         // ç¸½å…±è½‰å¹¾åœˆ
        const BOSS3_P1_REST = 1400;             // ä¼‘æ¯æ™‚é–“ (ms)
        const BOSS3_P1_SPEED = 1.2;             // å­å½ˆé€Ÿåº¦
        const BOSS3_P1_COLOR = 'lime';          // å­å½ˆé¡è‰²

        // --- æ¨¡å¼ 2: ç´«è‰²æ…¢é€Ÿæ•£å½ˆ (Shotgun) ---
        const BOSS3_P2_BURST_COUNT = 3;         // é€£çºŒç™¼å°„å¹¾æ³¢
        const BOSS3_P2_INTERVAL = 500;          // æ¯æ³¢é–“éš” (ms)
        const BOSS3_P2_SPREAD_ANGLE = 35;       // æ•£å½ˆè§’åº¦ç¯„åœ
        const BOSS3_P2_BULLETS_NUM = 3;         // æ¯æ¬¡ç™¼å°„å¹¾é¡†
        const BOSS3_P2_SPEED = 0.5;             // é€Ÿåº¦å¾ˆæ…¢
        //const BOSS3_P2_COLOR = '#9932CC';       // ç´«è‰² (DarkOrchid)
        const BOSS3_P2_COLOR = 'lime';       // ç´«è‰² (DarkOrchid)
        const BOSS3_P2_REST = 500;             // ä¼‘æ¯æ™‚é–“ (ms)

        // --- æ¨¡å¼ 3: ç´…è‰²è¶…å¿«ç‹™æ“Š (Sniper) ---
        const BOSS3_P3_SPEED = 1.5;             // é€Ÿåº¦è¶…å¿«
        //const BOSS3_P3_COLOR = 'red';           // ç´…è‰²
        const BOSS3_P3_COLOR = 'lime';           // ç´…è‰²
        const BOSS3_P3_REST = 300;             // ä¼‘æ¯æ™‚é–“ (ms)
	const BOSS3_P3_SMEAR_ANGLE = 40;        // ç‹™æ“Šå½ˆçš„éš¨æ©Ÿèª¤å·®ç¯„åœ (åº¦)



// --- æ¨¡å¼ 4: ä¸‰æ®µå¼é€£æ‹› (Phase 4) ---
const BOSS3_P4_OFFSET_ANGLE = 30;    
const BOSS3_P4_OFFSET_COLOR = 'orange'; 
const BOSS3_P4_WAIT_TIME = 2500;     // ç¬¬ä¸€æ®µèˆ‡ç¬¬äºŒæ®µé–“éš”

const BOSS3_P4_SPREAD_COUNT = 20;    
const BOSS3_P4_SPREAD_RANGE = 40;    
const BOSS3_P4_SPREAD_COLOR = 'orange'; 

// âœ¨ æ–°å¢ï¼šç¬¬ä¸‰æ®µéš¨æ©Ÿé€£ç™¼åƒæ•¸
const BOSS3_P4_RAPID_COUNT = 40;     // é€£ç™¼ 20 é¡†
const BOSS3_P4_RAPID_RANGE = 20;     // 20 åº¦å…§éš¨æ©Ÿ
const BOSS3_P4_RAPID_INTERVAL = 25;  // æ¯é¡†é–“éš” 50ms
const BOSS3_P4_RAPID_COLOR = 'cyan'; // é€£ç™¼å­å½ˆé¡è‰²
const BOSS3_P4_RAPID_SPEED = 2.8;      // é€£ç™¼é€Ÿåº¦ç¨å¾®å¿«ä¸€é»

const BOSS3_P4_REST = 13000;         // æœ€çµ‚ä¼‘æ¯ 10 ç§’
const BOSS3_P4_BULLET_SPEED = 3;
        // ==========================================






        const BOSS_BASE_CONFIG = { 
            type: 99, 
            baseHp: 600.0, 
            score: 100, 
            color: 'darkred', 
            className: 'boss-enemy' 
        };


        // æ­¦å™¨åŸºç¤é…ç½®
        const BASE_WEAPONS = [
            { name: "å–®ç®¡æ©Ÿæ§", baseFireRate: BASE_SINGLE_SHOT_RATE, color: "white", bulletSpeed: 4.5, type: "single", baseDamage: 1.0 },        
            { name: "å»£åŸŸéœ°å½ˆ", baseFireRate: 1200 * INITIAL_FIRE_RATE_MODIFIER, color: "yellow", bulletSpeed: 6, type: "random_spread_15", baseDamage: 2.0 },  
            { name: "æƒ¡ç«é‡æ©Ÿæ§", baseFireRate: 215 * INITIAL_FIRE_RATE_MODIFIER, color: "lime", bulletSpeed: 4.5, type: "random_twin", baseDamage: 2.0 }, 
            { name: "éœé›»åŠ›å ´", baseFireRate: STATIC_FIELD_RATE, color: "red", bulletSpeed: 0, type: "static_field", baseDamage: STATIC_FIELD_DAMAGE },
            { name: "è„ˆè¡ç«ç„°", baseFireRate: SWORD_BLADE_RATE, color: "blue", bulletSpeed: 0, type: "continuous_sword", baseDamage: SWORD_BLADE_DAMAGE }, 
	    { name: "å……èƒ½é›·å°„", baseFireRate: 65 * INITIAL_FIRE_RATE_MODIFIER, color: "cyan", bulletSpeed: 0, type: "kinetic_laser", baseDamage: 1.0 }
        ];

        const STATIC_FIELD_WEAPON_INDEX = 3; 
        const SWORD_BLADE_WEAPON_INDEX = 4;
	const KINETIC_LASER_WEAPON_INDEX = 5; // æ–°å¢ç´¢å¼•

        const container = document.getElementById('game-container');
        const player = document.getElementById('player');
        const scoreElement = document.getElementById('score');
        const hpElement = document.getElementById('player-hp'); 
        const weaponNameElement = document.getElementById('weapon-name');
        const fireRateInfoElement = document.getElementById('fire-rate-info');
        const startMessageElement = document.getElementById('start-message'); 
        const gameOverMessageElement = document.getElementById('game-over-message');
        const finalScoreElement = document.getElementById('final-score');
        const staticFieldAura = document.getElementById('static-field-aura'); 
        const continuousSwordBlade = document.getElementById('continuous-sword-blade');
        const dpsDisplayElement = document.getElementById('current-dps');
        const pauseMessageElement = document.getElementById('pause-message');

        const Game = {
            width: 500,
            height: 600, 
            score: 0,
            scoreLevel: 0, 
            fireRateMultiplier: 1.0, 
            bullets: [],          
            enemies: [],          
            enemyBullets: [],     
            drops: [],
            lastEnemyTime: 0,
            enemyInterval: 800, 
            spawnRateMultiplier: 1.0,           
            spawnAccumulator: 0,                
            isRunning: true,
            isGameActive: false,
            isPaused: false,
            
            // Boss ç›¸é—œç‹€æ…‹
            gameState: 'NORMAL', 
            boss: null, 
            bossSpawnTime: 0, 
            bossPrepDuration: BOSS_PREP_DURATION, 
            bossCount: 0, // æ“Šæ•—éå¹¾æ¬¡ Boss
            
            // Boss å°„æ“Šç‹€æ…‹ (é€šç”¨)
            bossShotState: {
                isCoolingDown: false,
                lastBurstTime: 0,
                burstCounter: 0,
                lastShotTime: 0, 
                // Boss 2 å°ˆç”¨ç‹€æ…‹
                phase: 0, // 0: Shotgun, 1: Rest, 2: Rapid, 3: Rest
                phaseStartTime: 0
            },

            player: {
                x: 241, 
                y: 291, 
                speed: 0.6, 
                width: 18, 
                height: 18, 
                hp: MAX_PLAYER_HP,            
            },
            mouse: { x: 0, y: 0, isFiring: false }, 
            
            weapons: JSON.parse(JSON.stringify(BASE_WEAPONS)), 
            currentWeaponIndex: 0,
            
            fireAccumulators: [0, 0, 0], 
            
            lastStaticDamageTime: 0, 
            lastSwordDamageTime: 0, 
            currentSwordAngle: 0, 
            
            lastDashTime: 0,
            dashCooldown: 3000, 
            
            lastPlayerHitTime: 0, 
            isInvincible: false, 
            
            lastFrameTime: 0,
            
            damageRecords: [], 
            lastDPSTime: 0,

	    // --- æ–°å¢ï¼šå……èƒ½é›·å°„å°ˆç”¨è®Šæ•¸ ---
    	    kineticChargeTime: 0, // ç•¶å‰ç´¯ç©çš„æ¯«ç§’æ•¸
    	    isPlayerMoving: false, // è¿½è¹¤ç©å®¶æ˜¯å¦ç§»å‹•
	    // --- æ–°å¢ï¼šéœæ­¢è¨ˆæ™‚å™¨ ---
    	    timeStopped: 0, // è¿½è¹¤ç©å®¶åœæ­¢ç§»å‹•ç´¯ç©çš„æ¯«ç§’æ•¸


    hmgState: {
        lastMoveTime: 0,
        isOverloading: false,
        overloadStartTime: 0,
        isCoolingDown: false,
        cooldownEndTime: 0
    }



        };
        
        let isWeaponKeyHeld = false;

        function getPlayerCenter() {
            return {
                x: Game.player.x + Game.player.width / 2,
                y: Game.player.y + Game.player.height / 2
            };
        }

        function normalizeAngle(angle) {
            const TWO_PI = 2 * Math.PI;
            let result = angle % TWO_PI;
            if (result < 0) result += TWO_PI;
            return result;
        }
        
        function getShortestAngleDiff(current, target) {
            let diff = target - current;
            const TWO_PI = 2 * Math.PI;
            if (diff > Math.PI) diff -= TWO_PI;
            else if (diff < -Math.PI) diff += TWO_PI;
            return diff;
        }

        function getEnemyHP(baseConfig) {
            const multiplier = 1.0 + Game.scoreLevel * 0.1; 
            return baseConfig.baseHp * multiplier; 
        }

        function getEnemyScore(baseConfig) { return baseConfig.score; }

        function updateWeaponStats() {
            const fireMultiplier = Game.fireRateMultiplier; 
            const damageBonusLevel = Math.floor(Game.score / 10000);
            const damageBonus = damageBonusLevel * 0.00;

            Game.weapons.forEach((weapon, index) => {
                weapon.fireRate = BASE_WEAPONS[index].baseFireRate / fireMultiplier; 
                if (index >= 0 && index <= 2) { 
                    weapon.damage = BASE_WEAPONS[index].baseDamage + damageBonus; 
                } else {
                    weapon.damage = BASE_WEAPONS[index].baseDamage;
                }
            });
            updateWeaponStatusDisplay();
        }
        
        function updateWeaponStatusDisplay() {
            const currentWeapon = Game.weapons[Game.currentWeaponIndex];
            weaponNameElement.innerText = currentWeapon.name;
            const rateText = `${Math.round(currentWeapon.fireRate)}ms`; 
            fireRateInfoElement.innerText = rateText;
        }

        function enemyHitEffect(enemy) {
            const originalColor = enemy.element.style.backgroundColor;
            const originalShadow = enemy.element.style.boxShadow; 
            enemy.element.style.backgroundColor = 'white';
            


	    if (enemy.type >= 99) { // æ‰€æœ‰çš„ Boss é¡å‹ (99, 100, 101...)
	        enemy.element.style.boxShadow = '0 0 20px 10px white, inset 0 0 10px red';
    	    } else {
            	enemy.element.style.boxShadow = '0 0 10px white';
    	    }

	setTimeout(() => {
        	if (enemy.hp > 0) {
            	// âœ¨ é—œéµä¿®æ­£ï¼šå„ªå…ˆè®Šå›æˆ‘å€‘åœ¨ createBoss ä¸­è¨­å®šå¥½çš„ baseColor
            	if (enemy.baseColor) {
                	enemy.element.style.backgroundColor = enemy.baseColor;
            	} else {
                	// æ™®é€šå°æ€ªå›æ­¸è¨­å®šæª”ä¸­çš„é¡è‰²
                	const config = BASE_ENEMY_CONFIGS.find(c => c.type === enemy.type);
                	if (config) {
                    	enemy.element.style.backgroundColor = config.color;
                	}
            	}
            	enemy.element.style.boxShadow = originalShadow;
        	}
    	}, 50);




        }

        function recordDamage(damage) {
            const now = performance.now();
            Game.damageRecords.push({ time: now, damage: damage });
        }
        
        function updateDPS(timestamp) {
            if (timestamp - Game.lastDPSTime >= DPS_UPDATE_INTERVAL) {
                Game.lastDPSTime = timestamp;
                const timeWindow = timestamp - DPS_WINDOW_SIZE;
                Game.damageRecords = Game.damageRecords.filter(record => record.time >= timeWindow);
                const totalDamage = Game.damageRecords.reduce((sum, record) => sum + record.damage, 0);
                const currentDPS = (totalDamage / DPS_WINDOW_SIZE) * 1000;
                dpsDisplayElement.innerText = currentDPS.toFixed(1); 
            }
        }
        
        function updateScore(points) {
            const oldLevel = Game.scoreLevel;
            const oldScore = Game.score;
            Game.score += points;
            scoreElement.innerText = Game.score;

            // Boss æˆ°æ©Ÿåˆ¶å•Ÿå‹•æª¢æŸ¥
            // 20000åˆ† -> Boss 1
            // 50000åˆ† -> Boss 2
            let spawnBoss = false;
            let bossName = "";

            if (Game.gameState === 'NORMAL') {
                if (Game.bossCount === 0 && Game.score >= 20000) {
                    spawnBoss = true;
                    bossName = "Boss 1";
                } else if (Game.bossCount === 1 && Game.score >= 50000) {
                    spawnBoss = true;
                    bossName = "Boss 2";
                }
		// *** æ–°å¢é€™æ®µ ***
                else if (Game.bossCount === 2 && Game.score >= BOSS3_TRIGGER_SCORE) {
                    spawnBoss = true;
                    bossName = "Boss 3";
                }
            }

            if (spawnBoss) {
                Game.gameState = 'BOSS_PREP';
                Game.bossSpawnTime = performance.now();
                
                const messageDiv = document.createElement('div');
                messageDiv.id = 'boss-warning-message';
                messageDiv.style.cssText = 'position: absolute; top: 10%; left: 50%; transform: translateX(-50%); font-size: 24px; color: red; text-shadow: 0 0 10px yellow; z-index: 12; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px;';
                messageDiv.innerHTML = `!!! è­¦å‘Šï¼š${bossName} å³å°‡å‡ºç¾ !!!`;
                container.appendChild(messageDiv);
                
                Game.enemies.forEach(e => container.removeChild(e.element));
                Game.enemies = [];
                Game.bullets.forEach(b => container.removeChild(b.element));
                Game.bullets = [];
                Game.enemyBullets.forEach(b => container.removeChild(b.element));
                Game.enemyBullets = [];
                Game.drops.forEach(d => container.removeChild(d.element));
                Game.drops = [];
		
		const centerX = GAME_CENTER.x - 7.5; 
    		const centerY = GAME_CENTER.y - 7.5;
                createHeartDrop(centerX, centerY);
                setTimeout(() => {
                    const msg = document.getElementById('boss-warning-message');
                    if (msg) container.removeChild(msg);
                }, BOSS_PREP_DURATION); 
            }

            const newLevel = Math.floor(Game.score / 2000);
            if (newLevel > oldLevel) {
                Game.scoreLevel = newLevel;
                Game.fireRateMultiplier = 1.0 + newLevel * 0.1; 
                updateWeaponStats(); 
                Game.spawnRateMultiplier = 1.0 + newLevel * 0.0085; 
            }
        }
        
        function updatePlayerPosition() {
            player.style.left = `${Game.player.x}px`;
            player.style.top = `${Game.player.y}px`;
            
            const center = getPlayerCenter();
            const radius = STATIC_FIELD_RANGE;
            const diameter = radius * 2; 
            const borderWidth = 2; 
            
            staticFieldAura.style.width = `${diameter}px`;
            staticFieldAura.style.height = `${diameter}px`;
            staticFieldAura.style.left = `${center.x - radius - borderWidth}px`; 
            staticFieldAura.style.top = `${center.y - radius - borderWidth}px`;  
        }

        function updateHPDisplay() {
            hpElement.innerText = Math.ceil(Game.player.hp);
        }

        function gameOver() {
            Game.isRunning = false;
            Game.isGameActive = false;
            finalScoreElement.innerText = `æœ€çµ‚åˆ†æ•¸: ${Game.score}`;
            gameOverMessageElement.style.display = 'block';
            pauseMessageElement.style.display = 'none';
        }

        function performDash(timestamp) {
            if (timestamp - Game.lastDashTime >= Game.dashCooldown) {
		        player.classList.remove('player-dash-ready');
                const targetX = Game.mouse.x - Game.player.width / 2;
                const targetY = Game.mouse.y - Game.player.height / 2;
                
                const maxX = Game.width; 
                const maxY = PLAYER_MAX_Y_BOUND; 

                Game.player.x = Math.max(0, Math.min(maxX - Game.player.width, targetX));
                Game.player.y = Math.max(0, Math.min(maxY - Game.player.height, targetY)); 

                updatePlayerPosition();
                Game.lastDashTime = timestamp;

                player.style.backgroundColor = 'white';
                setTimeout(() => {
                    if (!Game.isInvincible) { 
                        resetPlayerColor(); 
                    }
                }, 50);
            }
        }
        
        function resetPlayerColor() {
             const currentWeapon = Game.weapons[Game.currentWeaponIndex];
             player.style.boxShadow = 'none';
             if (Game.currentWeaponIndex === STATIC_FIELD_WEAPON_INDEX) {
                player.style.backgroundColor = 'darkviolet';
            } else if (Game.currentWeaponIndex === SWORD_BLADE_WEAPON_INDEX) {
                 player.style.backgroundColor = 'deepskyblue'; 
            } else {
                player.style.backgroundColor = currentWeapon.color === "white" ? "cyan" : currentWeapon.color; 
            }
        }

        function updateDashVisual(timestamp) {
            const dashReady = (timestamp - Game.lastDashTime >= Game.dashCooldown);
            if (dashReady) {
                player.classList.add('player-dash-ready');
            } else {
                player.classList.remove('player-dash-ready');
            }
        }

        function updateStaticFieldAura(isDamaging) {
             if (Game.currentWeaponIndex !== STATIC_FIELD_WEAPON_INDEX) return;
             if (isDamaging) {
                 staticFieldAura.classList.add('static-field-pulse');
                 setTimeout(() => {
                     staticFieldAura.classList.remove('static-field-pulse');
                 }, 150); 
             }
        }

        // *** Boss é‚è¼¯å€å¡Š ***

        function createBoss() {
	    // Game.bossCount = 0 -> Boss 1
            // Game.bossCount = 1 -> Boss 2
            // Game.bossCount = 2 -> Boss 3
            const bossIndex = Game.bossCount; 
            const config = BOSS_BASE_CONFIG;
            let currentHP = 600.0;
            let bossColor = 'darkred';
            let bossType = 99;
            let targetY = 80;
            if (bossIndex === 0) { // Boss 1
                currentHP = getEnemyHP(BOSS_BASE_CONFIG); // Boss 1
                bossColor = 'darkred';
                bossType = 99;
                targetY = 80;
	    }
            else if (bossIndex === 1) { // Boss 2
                currentHP = getEnemyHP(BOSS_BASE_CONFIG); // Boss 1
                bossColor = '#9370DB';
                bossType = 100;
                targetY = 60;
            } else if (bossIndex === 2) { // *** æ–°å¢ Boss 3 è¨­å®š ***
                currentHP = getEnemyHP(BOSS_BASE_CONFIG); // Boss 1
                bossColor = '#FFD700'; // é‡‘è‰²
                bossType = 101;
                targetY = BOSS3_Y_POS; // åƒæ•¸åŒ–ä½ç½®
            } else {
                 currentHP = getEnemyHP(BOSS_BASE_CONFIG); // Boss 1
            }
            
	    const boss = {
                x: Game.width / 2 - 100 / 2, 
                y: -100, 
                width: 100,
                height: 100,
                speed: 0.05, 
                hp: currentHP, 
                baseHp: currentHP, 
                score: 100,
                dropChance: 1.0, 
                lastShotTime: 0,
                element: document.createElement('div'),
                type: bossType, // è¨­å®šé¡å‹
                
                targetY: targetY, // è¨­å®šç›®æ¨™ Y
                isMovingToTarget: true, 
                
                moveOscillation: 0, 
                oscillationDirection: 1,
                
                baseColor: bossColor
            };

            boss.element.className = config.className;
            boss.element.innerHTML = Math.ceil(boss.hp); 
            boss.element.style.backgroundColor = bossColor;
            boss.element.style.left = `${boss.x}px`;
            boss.element.style.top = `${boss.y}px`;
            container.appendChild(boss.element);
            Game.boss = boss;
            Game.enemies.push(boss); 
            

	    // åˆå§‹åŒ–ç‹€æ…‹
            if (bossType === 100) {
                // ... Boss 2 ç‹€æ…‹ (ä¿æŒä¸è®Š)
                Game.bossShotState.phase = 0;
                Game.bossShotState.burstCounter = 0;
                Game.bossShotState.lastShotTime = performance.now();
                Game.bossShotState.phaseStartTime = performance.now();
            } else if (bossType === 101) { 
                // *** æ–°å¢ï¼šBoss 3 çš„ä¸‰å€‹ç¨ç«‹ç‹€æ…‹æ©Ÿ ***
                Game.boss3State = {
                    p1: { // æ—‹è½‰å½ˆå¹•
                        lastShot: 0,
                        angle: 0,
                        loopsDone: 0,
                        isResting: false,
                        restEnd: 0
                    },
                    p2: { // ç´«è‰²æ•£å½ˆ
                        lastShot: 0,
                        count: 0,
                        isResting: false,
                        restEnd: 0
                    },
                    p3: { // ç´…è‰²ç‹™æ“Š
                        isResting: false,
                        restEnd: 0
                    },
p4: {
    subPhase: 0,      
    nextActionTime: 0,
    rapidShotCounter: 0, // âœ¨ è¨˜éŒ„é€£ç™¼äº†å¹¾é¡†
    targetAngle: 0       // âœ¨ è¨˜éŒ„å™´æ•£å½ˆæ™‚çš„æ–¹å‘
}
                };
            }
        }

        function updateBossMovement(boss) {
            
            if (boss.isMovingToTarget) {
                if (boss.y < boss.targetY) {
                    boss.y = Math.min(boss.targetY, boss.y + boss.speed * 4); 
                } else {
                    boss.isMovingToTarget = false;
                }
            } else {
                const oscillationSpeed = 0.05; 
                const oscillationRange = 50; 
                
                boss.moveOscillation += boss.oscillationDirection * oscillationSpeed;
                
                if (boss.moveOscillation > oscillationRange || boss.moveOscillation < -oscillationRange) {
                    boss.oscillationDirection *= -1;
                }
                boss.x = Game.width / 2 - boss.width / 2 + boss.moveOscillation;
            }

            boss.element.style.top = `${boss.y}px`;
            boss.element.style.left = `${boss.x}px`;
        }
        
        function bossShoot(boss, timestamp) {
            // Boss 1 é‚è¼¯
            if (boss.type === 99) {
                let state = Game.bossShotState;
                if (state.isCoolingDown) {
                    if (timestamp - state.lastBurstTime >= BOSS1_COOLDOWN_INTERVAL) {
                        state.isCoolingDown = false;
                        state.burstCounter = 0; 
                        state.lastShotTime = timestamp; 
                    }
                    return;
                }

                if (state.burstCounter < BOSS1_BURST_COUNT) {
                    if (timestamp - state.lastShotTime >= BOSS1_BURST_INTERVAL) {
                        state.lastShotTime = timestamp;
                        state.burstCounter++;
                        const playerCenter = getPlayerCenter();
                        const bossCenter = { x: boss.x + boss.width / 2, y: boss.y + boss.height / 2 };
                        const baseAngle = Math.atan2(playerCenter.y - bossCenter.y, playerCenter.x - bossCenter.x);
                        
                        const spreadRadians = 60 * (Math.PI / 180);
                        const halfSpreadRadians = spreadRadians / 2; 
                        
                        for (let i = 0; i < BOSS1_SPREAD_SHOTS; i++) {
                            const angleOffset = (Math.random() * 2 - 1) * halfSpreadRadians; 
                            createEnemyBullet(boss, playerCenter.x, playerCenter.y, angleOffset);
                        }

                        if (state.burstCounter >= BOSS1_BURST_COUNT) {
                            state.isCoolingDown = true;
                            state.lastBurstTime = timestamp;
                        }
                    }
                }
            } 
            // Boss 2 é‚è¼¯ (Type 100)
            else if (boss.type === 100) {
                let state = Game.bossShotState;
                
                // Phase 0: æ•£å½ˆ (Shotgun)
                // æœç©å®¶ 15åº¦ 3é¡†, é–“éš” 200ms, 5æ³¢
                if (state.phase === 0) {
                    if (state.burstCounter < BOSS2_PHASE_A_WAVES) {
                        if (timestamp - state.lastShotTime >= BOSS2_PHASE_A_INTERVAL) {
                            state.lastShotTime = timestamp;
                            state.burstCounter++;
                            
                            const playerCenter = getPlayerCenter();
                            const bossCenter = { x: boss.x + boss.width / 2, y: boss.y + boss.height / 2 };
                            const baseAngle = Math.atan2(playerCenter.y - bossCenter.y, playerCenter.x - bossCenter.x);
                            const spreadRad = 25 * (Math.PI / 180);
                            
                            // ç™¼å°„ 3 é¡†
                            createEnemyBullet(boss, playerCenter.x, playerCenter.y, 0); // ä¸­å¿ƒ
                            createEnemyBullet(boss, playerCenter.x, playerCenter.y, -spreadRad/2); // å·¦
                            createEnemyBullet(boss, playerCenter.x, playerCenter.y, spreadRad/2); // å³
                            createEnemyBullet(boss, playerCenter.x, playerCenter.y, -spreadRad/2.3); // å³
                            createEnemyBullet(boss, playerCenter.x, playerCenter.y, spreadRad/2.3); // å³
                            createEnemyBullet(boss, playerCenter.x, playerCenter.y, -3.1415/2); // å³
                            createEnemyBullet(boss, playerCenter.x, playerCenter.y, 3.1415/2); // å³
                            createEnemyBullet(boss, playerCenter.x, playerCenter.y, 3.1415); // å³
                            
                            // è¦–è¦º
                            boss.element.style.boxShadow = '0 0 30px 15px rgba(255, 100, 255, 1), inset 0 0 20px white';
                            setTimeout(() => {
                                boss.element.style.boxShadow = '0 0 20px 10px rgba(255, 0, 0, 0.8), inset 0 0 15px white';
                            }, 100);
                        }
                    } else {
                        // 5æ³¢çµæŸï¼Œé€²å…¥ Phase 1 (ä¼‘æ¯)
                        state.phase = 1;
                        state.phaseStartTime = timestamp;
                    }
                }
                // Phase 1: ä¼‘æ¯ 1 ç§’
                else if (state.phase === 1) {
                    if (timestamp - state.phaseStartTime >= BOSS2_REST_TIME) {
                        state.phase = 2;
                        state.burstCounter = 0;
                        state.lastShotTime = timestamp;
                    }
                }
                // Phase 2: é€£å°„ (Rapid Fire)
                // é€£ç™¼ 20 é¡†, é–“éš” 50ms, äº‚å°„ 45åº¦
                else if (state.phase === 2) {
                    if (state.burstCounter < BOSS2_PHASE_B_SHOTS) {
                        if (timestamp - state.lastShotTime >= BOSS2_PHASE_B_INTERVAL) {
                            state.lastShotTime = timestamp;
                            state.burstCounter++;
                            
                            const playerCenter = getPlayerCenter();
                            // ä¿®æ”¹é€™è£¡ï¼šåŠ å…¥éš¨æ©Ÿäº‚å°„ 45 åº¦ (å·¦å³å„ 22.5 åº¦)
                            const spreadRange = 45 * (Math.PI / 180); 
                            const randomOffset = (Math.random() * spreadRange) - (spreadRange / 2);
                            
                            createEnemyBullet(boss, playerCenter.x, playerCenter.y, randomOffset);
                            createEnemyBullet(boss, playerCenter.x, playerCenter.y, -3.1415/2-randomOffset); // å³
                            createEnemyBullet(boss, playerCenter.x, playerCenter.y, 3.1415/2+randomOffset); // å³


                        }
                    } else {

                        // é€£å°„çµæŸï¼Œé€²å…¥ Phase 3 (ä¼‘æ¯)
                        state.phase = 3;
                        state.phaseStartTime = timestamp;
                    }
                }
                // Phase 3: ä¼‘æ¯ 1 ç§’ -> å›åˆ° Phase 0
                else if (state.phase === 3) {
                    if (timestamp - state.phaseStartTime >= BOSS2_REST_TIME) {
                        state.phase = 0;
                        state.burstCounter = 0;
                        state.lastShotTime = timestamp;
                    }
                }
            }


	    // *** æ–°å¢ï¼šBoss 3 é‚è¼¯ (Type 101) ***
            else if (boss.type === 101) {
                const s = Game.boss3State;
                const bossCenterX = boss.x + boss.width / 2;
                const bossCenterY = boss.y + boss.height / 2;
                const playerCenter = getPlayerCenter();

                // -------------------------------------------------
                // æ¨¡å¼ 1: å…¨æ–¹ä½é †æ™‚é‡æ—‹è½‰ (ç¨ç«‹é‹è¡Œ)
                // -------------------------------------------------
                if (s.p1.isResting) {
                    if (timestamp >= s.p1.restEnd) {
                        s.p1.isResting = false;
                        s.p1.angle = 0; // é‡ç½®è§’åº¦
                        s.p1.loopsDone = 0;
                        s.p1.lastShot = timestamp;
                    }
                } else {
                    if (timestamp - s.p1.lastShot >= BOSS3_P1_INTERVAL) {
                        // è¨ˆç®—è§’åº¦å¢é‡: (360åº¦ / è½‰ä¸€åœˆç§’æ•¸) * (é–“éš”/1000)
                        const anglePerStep = (360 / BOSS3_P1_ROTATION_SEC) * (BOSS3_P1_INTERVAL / 1000);
                        
                        createEnemyBulletManual(
                            bossCenterX, bossCenterY, 
                            s.p1.angle * (Math.PI / 180), 
                            BOSS3_P1_SPEED, 
                            BOSS3_P1_COLOR
                        );

                        s.p1.angle += anglePerStep;
                        s.p1.lastShot = timestamp;

                        // æª¢æŸ¥æ˜¯å¦å®ŒæˆæŒ‡å®šåœˆæ•¸
                        if (s.p1.angle >= 360 * BOSS3_P1_TOTAL_LOOPS) {
                            s.p1.isResting = true;
                            s.p1.restEnd = timestamp + BOSS3_P1_REST;
                        }
                    }
                }

                // -------------------------------------------------
                // æ¨¡å¼ 2: ç´«è‰²æ•£å½ˆ (ç¨ç«‹é‹è¡Œ)
                // -------------------------------------------------
                if (s.p2.isResting) {
                    if (timestamp >= s.p2.restEnd) {
                        s.p2.isResting = false;
                        s.p2.count = 0;
                        s.p2.lastShot = timestamp;
                    }
                } else {
                    if (s.p2.count < BOSS3_P2_BURST_COUNT) {
                        if (timestamp - s.p2.lastShot >= BOSS3_P2_INTERVAL) {
                            // è¨ˆç®—æœå‘ç©å®¶çš„åŸºç¤è§’åº¦
                            const baseAngle = Math.atan2(playerCenter.y - bossCenterY, playerCenter.x - bossCenterX);
                            const spreadRad = BOSS3_P2_SPREAD_ANGLE * (Math.PI / 180);
                            
                            // ç™¼å°„æ•£å½ˆ (BOSS3_P2_BULLETS_NUM é¡†)
                            for(let i=0; i<BOSS3_P2_BULLETS_NUM; i++) {
                                // è¨ˆç®—åç§»: è®“å­å½ˆå‡å‹»åˆ†ä½ˆåœ¨ spreadAngle å…§
                                let offset = 0;
                                if(BOSS3_P2_BULLETS_NUM > 1) {
                                    offset = (i / (BOSS3_P2_BULLETS_NUM - 1) - 0.5) * spreadRad;
                                }
                                createEnemyBulletManual(
                                    bossCenterX, bossCenterY, 
                                    baseAngle + offset, 
                                    BOSS3_P2_SPEED, 
                                    BOSS3_P2_COLOR
                                );
                            }
                            
                            s.p2.count++;
                            s.p2.lastShot = timestamp;
                        }
                    } else {
                        // ç™¼å°„å®Œç•¢ï¼Œé€²å…¥ä¼‘æ¯
                        s.p2.isResting = true;
                        s.p2.restEnd = timestamp + BOSS3_P2_REST;
                    }
                }

		// -------------------------------------------------
                // æ¨¡å¼ 3: ç´…è‰²ç‹™æ“Š (ç¨ç«‹é‹è¡Œ) - ä½¿ç”¨å°ˆå±¬èª¤å·®åƒæ•¸
                // -------------------------------------------------
                if (s.p3.isResting) {
                    if (timestamp >= s.p3.restEnd) {
                        s.p3.isResting = false;
                    }
                } else {
                    // 1. ç²å–æŒ‡å‘ç©å®¶çš„åŸºç¤è§’åº¦
                    const baseAngle = Math.atan2(playerCenter.y - bossCenterY, playerCenter.x - bossCenterX);
                    
                    // 2. è¨ˆç®—å°ˆå±¬æ¨¡å¼ä¸‰çš„éš¨æ©Ÿåç§» (æ­£è²  SMEAR_ANGLE/2)
                    // ä¾‹å¦‚ï¼š20åº¦ç¯„åœä»£è¡¨ç©å®¶ä¸­å¿ƒå¾€å·¦10åº¦åˆ°å¾€å³10åº¦
                    const halfSpread = BOSS3_P3_SMEAR_ANGLE / 2;
                    const randomOffsetDeg = (Math.random() * BOSS3_P3_SMEAR_ANGLE) - halfSpread;
                    const randomOffsetRad = randomOffsetDeg * (Math.PI / 180);
                    
                    // 3. çµåˆéš¨æ©Ÿè§’åº¦
                    const finalAngle = baseAngle + randomOffsetRad;

                    createEnemyBulletManual(
                        bossCenterX, bossCenterY, 
                        finalAngle, 
                        BOSS3_P3_SPEED, 
                        BOSS3_P3_COLOR
                    );

                    // ç™¼å°„å¾Œé€²å…¥ä¼‘æ¯
                    s.p3.isResting = true;
                    s.p3.restEnd = timestamp + BOSS3_P3_REST;
                }

		// -------------------------------------------------
                // æ¨¡å¼ 4: ä¸‰æ®µå¼é€£æ‹› (å·¦å³ç‹™æ“Š -> å¤§æ•£å½ˆ -> éš¨æ©Ÿé€£ç™¼)
                // -------------------------------------------------
                const p4 = s.p4;
                if (timestamp >= p4.nextActionTime) {
                    if (p4.subPhase === 0) {
                        // ã€éšæ®µ Aã€‘å™´å…©é¡†å­å½ˆ (å·¦å³ 30 åº¦)
                        const baseAngle = Math.atan2(playerCenter.y - bossCenterY, playerCenter.x - bossCenterX);
                        const offsetRad = BOSS3_P4_OFFSET_ANGLE * (Math.PI / 180);

                        [baseAngle - offsetRad, baseAngle + offsetRad].forEach(angle => {
                            createEnemyBulletManual(bossCenterX, bossCenterY, angle, BOSS3_P4_BULLET_SPEED, BOSS3_P4_OFFSET_COLOR);
                        });

                        p4.subPhase = 1;
                        p4.nextActionTime = timestamp + BOSS3_P4_WAIT_TIME;

                    } else if (p4.subPhase === 1) {
                        // ã€éšæ®µ Bã€‘å™´ 20 é¡†å¤§æ•£å½ˆ
                        const baseAngle = Math.atan2(playerCenter.y - bossCenterY, playerCenter.x - bossCenterX);
                        const startAngle = baseAngle - (BOSS3_P4_SPREAD_RANGE / 2) * (Math.PI / 180);
                        const angleStep = (BOSS3_P4_SPREAD_RANGE * (Math.PI / 180)) / (BOSS3_P4_SPREAD_COUNT - 1);

                        for (let i = 0; i < BOSS3_P4_SPREAD_COUNT; i++) {
                            const angle = startAngle + (angleStep * i);
                            createEnemyBulletManual(bossCenterX, bossCenterY, angle, BOSS3_P4_BULLET_SPEED - 0.5, BOSS3_P4_SPREAD_COLOR);
                        }

                        // âœ¨ æº–å‚™é€²å…¥ç¬¬ä¸‰éšæ®µï¼šè¨˜éŒ„æ–¹å‘èˆ‡é‡ç½®è¨ˆæ•¸å™¨
                        p4.targetAngle = baseAngle; // é–å®šå‰›æ‰å™´æ•£å½ˆçš„æ–¹å‘
                        p4.rapidShotCounter = 0;
                        p4.subPhase = 2;
                        p4.nextActionTime = timestamp; // ç«‹å³é–‹å§‹é€£ç™¼

                    } else if (p4.subPhase === 2) {
                        // ã€éšæ®µ Cã€‘éš¨æ©Ÿé€£ç™¼ 20 é¡† (æ¯é¡†é–“éš” 50ms)
                        if (p4.rapidShotCounter < BOSS3_P4_RAPID_COUNT) {
                            // åœ¨é–å®šçš„æ–¹å‘ 20 åº¦å…§éš¨æ©Ÿå–è§’
                            const halfRange = BOSS3_P4_RAPID_RANGE / 2;
                            const randomOffset = (Math.random() * BOSS3_P4_RAPID_RANGE - halfRange) * (Math.PI / 180);
                            const finalAngle = p4.targetAngle + randomOffset;

                            createEnemyBulletManual(
                                bossCenterX, bossCenterY,
                                finalAngle,
                                BOSS3_P4_RAPID_SPEED,
                                BOSS3_P4_RAPID_COLOR
                            );

                            p4.rapidShotCounter++;
                            p4.nextActionTime = timestamp + BOSS3_P4_RAPID_INTERVAL; // 50ms å¾Œä¸‹ä¸€ç™¼
                        } else {
                            // é€£ç™¼çµæŸï¼Œé€²å…¥å¤§ä¼‘æ¯
                            p4.subPhase = 3;
                            p4.nextActionTime = timestamp + BOSS3_P4_REST;
                        }

                    } else if (p4.subPhase === 3) {
                        // 10 ç§’ä¼‘æ¯çµæŸï¼Œé‡ç½®å¾ªç’°
                        p4.subPhase = 0;
                    }
                }


            }
        }

        // *** éŠæˆ²è¿´åœˆ ***
        function gameLoop(timestamp) {
            if (!Game.isRunning) return;
            
            handleInput(timestamp); 
            updateDashVisual(timestamp);
            
            if (Game.isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            const now = timestamp; 
            
            if (Game.lastFrameTime === 0) {
                Game.lastFrameTime = now;
            }
            const dt = now - Game.lastFrameTime;
            Game.lastFrameTime = now;

            if (Game.isGameActive) { 
                
                const currentWeaponIndex = Game.currentWeaponIndex;
                updateDPS(now); 

                if (currentWeaponIndex === STATIC_FIELD_WEAPON_INDEX) {
                    updateStaticField(now);
                    continuousSwordBlade.style.display = 'none';
                } else if (currentWeaponIndex === SWORD_BLADE_WEAPON_INDEX) {
                    updateContinuousSword(now); 
                } else if (currentWeaponIndex === KINETIC_LASER_WEAPON_INDEX) {
    		    updateKineticLaser(now, dt);
    		    continuousSwordBlade.style.display = 'none';
		}else {
                    playerShoot(now, dt);    
                    continuousSwordBlade.style.display = 'none';
                }
                
                if (Game.gameState === 'BOSS_PREP' && now - Game.bossSpawnTime >= Game.bossPrepDuration) {
                    createBoss();
                    Game.gameState = 'BOSS_FIGHT';
                    updateBossMovement(Game.boss);
                }
                
                if (Game.gameState === 'BOSS_FIGHT' && Game.boss) {
                    updateBossMovement(Game.boss);
                    bossShoot(Game.boss, now);
                    
                    Game.boss.element.innerHTML = Math.ceil(Game.boss.hp); 
                    
                    if (Game.boss.hp <= 0) {
                         const bossScore = Game.boss.score;
                         const bossDropChance = Game.boss.dropChance;

                        container.removeChild(Game.boss.element);
                        
                        if (bossDropChance > 0 && Math.random() < bossDropChance) {
                             createHeartDrop(Game.boss.x + Game.boss.width / 2 - 7, Game.boss.y + Game.boss.height / 2 - 7);
                        }
                        
                        Game.boss = null;
                        Game.enemies = []; 
                        
                        // Boss æ“Šæ•—å¾Œï¼ŒBossè¨ˆæ•¸+1
                        Game.bossCount++; 
                        
                        Game.gameState = 'NORMAL'; 
                        updateScore(bossScore); 
                        
                        // é‡ç½® Boss 1 å°„æ“Šç‹€æ…‹
                        Game.bossShotState = {
                            isCoolingDown: false,
                            lastBurstTime: 0,
                            burstCounter: 0,
                            lastShotTime: 0,
                            phase: 0, // Reset phase for next boss
                            phaseStartTime: 0
                        };
                        
                        const messageDiv = document.createElement('div');
                        messageDiv.style.cssText = 'position: absolute; top: 10%; left: 50%; transform: translateX(-50%); font-size: 24px; color: lime; text-shadow: 0 0 10px green; z-index: 12; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px;';
                        messageDiv.innerHTML = '!!! Boss è¢«æ“Šæ•—ï¼æ•µè»ç”Ÿæˆæ¢å¾© !!!';
                        container.appendChild(messageDiv);
                        setTimeout(() => {
                            if (container.contains(messageDiv)) container.removeChild(messageDiv);
                        }, 5000); 
                    }
                }

                updateBullets();
                spawnEnemy(now);
                updateEnemies(now); 
                updateEnemyBullets(); 
                updateDrops(); 
                checkCollisions(now); 
                cleanupObjects();
            }
            requestAnimationFrame(gameLoop); 
        }

        function updateContinuousSword(timestamp) {
            const weapon = Game.weapons[SWORD_BLADE_WEAPON_INDEX];
            const center = getPlayerCenter();
            
            const targetAngle = Math.atan2(Game.mouse.y - center.y, Game.mouse.x - center.x);
            const angleDiff = getShortestAngleDiff(Game.currentSwordAngle, targetAngle);
            const maxRotation = SWORD_ROTATION_SPEED;
            let rotationStep = 0;
            
            if (Math.abs(angleDiff) > maxRotation) {
                rotationStep = Math.sign(angleDiff) * maxRotation;
            } else {
                rotationStep = angleDiff;
            }
            
            Game.currentSwordAngle += rotationStep;

            const visualAngle = Game.currentSwordAngle + Math.PI / 2;
            continuousSwordBlade.style.setProperty('--current-rotation', `${visualAngle}rad`); 
            continuousSwordBlade.style.transform = `rotate(${visualAngle}rad)`; 
            
            const swordBaseX = center.x;
            const swordBaseY = center.y;

            continuousSwordBlade.style.left = `${swordBaseX - SWORD_BLADE_WIDTH / 2}px`;
            continuousSwordBlade.style.top = `${swordBaseY - SWORD_BLADE_HEIGHT}px`;
            
            continuousSwordBlade.style.display = 'block';

            if (timestamp - Game.lastSwordDamageTime >= weapon.fireRate) {
                Game.lastSwordDamageTime = timestamp;

                const enemiesToRemove = [];
                let swordDamaged = false;
                
                const dx = Math.cos(Game.currentSwordAngle);
                const dy = Math.sin(Game.currentSwordAngle);
                const halfWidth = SWORD_BLADE_WIDTH / 4; 
                
                const damagePoints = [];
                for (let i = 0; i <= SWORD_DAMAGE_POINTS; i++) {
                    const distance = (i / SWORD_DAMAGE_POINTS) * SWORD_BLADE_HEIGHT;
                    
                    damagePoints.push({
                        x: swordBaseX + distance * dx,
                        y: swordBaseY + distance * dy
                    });
                }

                Game.enemies.forEach((enemy, eIndex) => {
                    const enemyCenter = { x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height / 2 };
                    const enemyRadius = enemy.width / 2;
                    let isHit = false;

                    for (const point of damagePoints) {
                        const distanceToEnemy = Math.sqrt(
                            Math.pow(point.x - enemyCenter.x, 2) + 
                            Math.pow(point.y - enemyCenter.y, 2)
                        );
                        
                        if (distanceToEnemy <= enemyRadius + halfWidth) { 
                             isHit = true;
                             break;
                        }
                    }

                    if (isHit) { 
                        enemyHitEffect(enemy);
                        swordDamaged = true;
                        
                        const damage = weapon.damage; 
                        enemy.hp -= damage; 
                        enemy.element.innerHTML = Math.ceil(enemy.hp); 
                        recordDamage(damage); 
                        
                        if (enemy.hp <= 0 && enemy.type < 99) {
                            enemiesToRemove.push(eIndex);
                            updateScore(enemy.score); 
                            if (enemy.dropChance > 0 && Math.random() < enemy.dropChance) {
                                createHeartDrop(enemy.x + enemy.width / 2 - 7, enemy.y + enemy.height / 2 - 7);
                            }
                        }
                    }
                });

                cleanupHits(Game.enemies, enemiesToRemove);
                
                if (swordDamaged) {
                    continuousSwordBlade.classList.add('sword-hit-effect');
                    setTimeout(() => {
                         continuousSwordBlade.classList.remove('sword-hit-effect');
                    }, 50);
                }
            }
        }

        function updateStaticField(timestamp) {
            const currentWeapon = Game.weapons[STATIC_FIELD_WEAPON_INDEX];
            
            if (timestamp - Game.lastStaticDamageTime >= currentWeapon.fireRate) {
                Game.lastStaticDamageTime = timestamp;
                const playerCenter = getPlayerCenter();
                const damageDoneEnemies = []; 
                let fieldDamaged = false; 

                Game.enemies.forEach((enemy, eIndex) => {
                    const enemyCenter = { x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height / 2 };
                    const distance = Math.sqrt(
                        Math.pow(enemyCenter.x - playerCenter.x, 2) + 
                        Math.pow(enemyCenter.y - playerCenter.y, 2)
                    );
                    
                    const enemyRadius = enemy.width / 2; 
                    if (distance <= STATIC_FIELD_RANGE + enemyRadius) { 
                        if (!damageDoneEnemies.includes(eIndex)) {
                            enemyHitEffect(enemy); 
                            const damage = currentWeapon.damage; 
                            enemy.hp -= damage; 
                            enemy.element.innerHTML = Math.ceil(enemy.hp);
                            damageDoneEnemies.push(eIndex);
                            fieldDamaged = true; 
                            recordDamage(damage); 
                            
                            if (enemy.hp <= 0 && enemy.type < 99) {
                                cleanupHits(Game.enemies, [eIndex]);
                                updateScore(enemy.score); 
                                if (enemy.dropChance > 0 && Math.random() < enemy.dropChance) {
                                    createHeartDrop(enemy.x + enemy.width / 2 - 7, enemy.y + enemy.height / 2 - 7);
                                }
                            }
                        }
                    }
                });
                
                if (fieldDamaged) {
                    updateStaticFieldAura(true);
                }
            }
        }




// --- ä¿®æ”¹å¾Œçš„å‡½æ•¸ï¼šç§»å‹•è“„åŠ› + éœæ­¢å»¶é²ç™¼å°„é‚è¼¯ ---
const STOP_THRESHOLD_MS = 400; // éœæ­¢ç™¼å°„é–€æª»å€¼ (1 ç§’)

function updateKineticLaser(timestamp, dt) {
    const weapon = Game.weapons[KINETIC_LASER_WEAPON_INDEX];

    // ç‹€æ…‹ A: åˆ¤æ–·ç©å®¶æ˜¯å¦æ­£åœ¨ç§»å‹•
    if (Game.isPlayerMoving) {
        // ç©å®¶ç§»å‹•ï¼š
        
        // 1. æŒçºŒè“„åŠ› (ç§»å‹•æ™‚æ‰ç´¯ç©å‚·å®³)
        Game.kineticChargeTime += dt;
        
        // 2. é¡¯ç¤ºè“„åŠ›é¡è‰² (ç™¼å‡ºå…‰èŠ’)
	player.classList.add('laser-charging-alt2'); 
        player.classList.remove('player-charging'); // ç§»é™¤èˆŠçš„/é€šç”¨çš„è“„åŠ› class
        
        // 3. æ¸…é™¤éœæ­¢è¨ˆæ™‚å™¨ (ç§»å‹•æ™‚ï¼Œéœæ­¢è¨ˆæ™‚æ­¸é›¶)
        Game.timeStopped = 0;
        
    } else {
        // ç‹€æ…‹ B: ç©å®¶åœæ­¢
        
        // 1. åœæ­¢è“„åŠ› (Game.kineticChargeTime ä¸å¢åŠ )
        
        // 2. ç§»é™¤è“„åŠ›é¡è‰² (å› ç‚ºåœæ­¢è“„åŠ›äº†ï¼Œå…‰èŠ’æ‡‰æ¸›å¼±æˆ–æ¶ˆå¤±)
    	player.classList.add('laser-charging-alt'); 
        player.classList.remove('laser-charging-alt2'); 
        player.classList.remove('player-charging');
        
        // 3. ç¹¼çºŒè¨ˆç®—éœæ­¢æ™‚é–“
        Game.timeStopped += dt;

        // 4. æª¢æŸ¥æ˜¯å¦é”åˆ°ç™¼å°„é–¾å€¼ (éœæ­¢è¶…é 1 ç§’)
        if (Game.timeStopped >= STOP_THRESHOLD_MS) {
            
            // æª¢æŸ¥æ˜¯å¦æœ‰è¶³å¤ çš„è“„åŠ›æ™‚é–“ä¾†ç™¼å°„
            if (Game.kineticChargeTime > 100) { 
                
                // 1. è¨ˆç®—å‚·å®³å€ç‡
                const ratio = Game.kineticChargeTime / weapon.fireRate;
                const finalDamage = weapon.damage * ratio;
                
                // 2. ç™¼å°„é›·å°„
                fireKineticLaser(finalDamage);

                // 3. é‡ç½®æ‰€æœ‰è¨ˆæ™‚å™¨
                Game.kineticChargeTime = 0;
                Game.timeStopped = 0;
            }
        }
    }
}
// ------------------------------------------------




function fireKineticLaser(damage) {
    const center = getPlayerCenter();
    const angle = Math.atan2(Game.mouse.y - center.y, Game.mouse.x - center.x);
    
    // 1. è¦–è¦ºæ•ˆæœï¼šå»ºç«‹é›·å°„ DOM
    const laserLength = 1000; // è¶³å¤ é•·ç©¿éè¢å¹•
    const laser = document.createElement('div');
    laser.className = 'laser-beam';
    laser.style.width = `${laserLength}px`;
    laser.style.left = `${center.x}px`;
    laser.style.top = `${center.y - 7}px`; // ä¿®æ­£å‚ç›´å±…ä¸­ (é«˜åº¦çš„ä¸€åŠ)
    laser.style.transform = `rotate(${angle}rad)`;
    container.appendChild(laser);
    
    // é›·å°„æ¶ˆå¤±å‹•ç•«
    setTimeout(() => { laser.style.opacity = '0'; }, 100);
    setTimeout(() => { if(laser.parentNode) laser.parentNode.removeChild(laser); }, 300);

    // 2. å‚·å®³è¨ˆç®— (å°„ç·šç¢°æ’æª¢æ¸¬)
    // æˆ‘å€‘ä½¿ç”¨ã€Œé»åˆ°ç›´ç·šè·é›¢ã€å…¬å¼ä¾†åˆ¤æ–·æ•µäººæ˜¯å¦åœ¨é›·å°„è·¯å¾‘ä¸Š
    // ç›´ç·šæ–¹ç¨‹å¼ç”± (center.x, center.y) å’Œè§’åº¦ angle æ±ºå®š
    
    // è¨ˆç®—ç›´ç·šå‘é‡ (ä¸€èˆ¬å¼ Ax + By + C = 0 ä¸å¥½ç”¨ï¼Œæˆ‘å€‘ç”¨å‘é‡æŠ•å½±æˆ–é»ç·šè·é›¢)
    // P1 = center, P2 = end of laser
    const p1 = center;
    const p2 = {
        x: center.x + Math.cos(angle) * laserLength,
        y: center.y + Math.sin(angle) * laserLength
    };

    const hitEnemies = [];

    Game.enemies.forEach((enemy, index) => {
        const enemyCenter = { x: enemy.x + enemy.width/2, y: enemy.y + enemy.height/2 };
        const enemyRadius = enemy.width / 2;
        
        // åˆ¤æ–· 1: æ•µäººæ˜¯å¦åœ¨å‰æ–¹ (é»ç© > 0)
        const vecPlayerToEnemy = { x: enemyCenter.x - p1.x, y: enemyCenter.y - p1.y };
        const vecLaser = { x: p2.x - p1.x, y: p2.y - p1.y };
        const dotProduct = vecPlayerToEnemy.x * vecLaser.x + vecPlayerToEnemy.y * vecLaser.y;
        
        if (dotProduct > 0) {
            // åˆ¤æ–· 2: è¨ˆç®—å‚ç›´è·é›¢
            // Area of parallelogram = |Cross Product|
            // Dist = |Cross Product| / |Base|
            const crossProduct = Math.abs(vecLaser.x * vecPlayerToEnemy.y - vecLaser.y * vecPlayerToEnemy.x);
            const laserLen = Math.sqrt(vecLaser.x**2 + vecLaser.y**2);
            const dist = crossProduct / laserLen;
            
            // åˆ¤å®šå¯¬åº¦ï¼šé›·å°„åŠå¯¬ (7px) + æ•µäººåŠå¾‘
            if (dist <= (7 + enemyRadius)) {
                // å‘½ä¸­ï¼
                enemyHitEffect(enemy);
                enemy.hp -= damage;
                enemy.element.innerHTML = Math.ceil(enemy.hp);
                recordDamage(damage);
                
                if (enemy.hp <= 0 && enemy.type < 99) {
                    hitEnemies.push(index);
                    updateScore(enemy.score);
                    if (enemy.dropChance > 0 && Math.random() < enemy.dropChance) {
                        createHeartDrop(enemy.x + enemy.width/2 - 7, enemy.y + enemy.height/2 - 7);
                    }
                }
            }
        }
    });
    
    cleanupHits(Game.enemies, hitEnemies);
}




        
        function spawnEnemy(timestamp) { 
            if (Game.gameState !== 'NORMAL') return; 

            if (timestamp - Game.lastEnemyTime > Game.enemyInterval) {
                const targetSpawn = Game.spawnRateMultiplier + Game.spawnAccumulator; 
                const actualSpawn = Math.floor(targetSpawn);
                Game.spawnAccumulator = targetSpawn - actualSpawn; 

                for (let i = 0; i < actualSpawn; i++) {
                    createSingleEnemy();
                }
                Game.lastEnemyTime = timestamp;
            }
        }

        function createSingleEnemy() { 
            let baseConfig;
            let isType2 = false; 
            let isGriefer = false; 
            
            const rand = Math.random();

            if (rand < 0.015) { 
                baseConfig = BASE_ENEMY_CONFIGS[2]; 
            } else if (rand < 0.015 + 0.15) { 
                baseConfig = BASE_ENEMY_CONFIGS[0]; 
            } else if (rand < 0.165 + 0.15) { 
                isType2 = true;
                baseConfig = BASE_ENEMY_CONFIGS[1]; 
            } else {
                isGriefer = true;
                baseConfig = BASE_ENEMY_CONFIGS[3]; 
            }
            
            const enemyWidth = baseConfig.className === 'rare-enemy' ? 50 : 30;
            const enemyHeight = baseConfig.className === 'rare-enemy' ? 50 : 30;

            let startX, startY;
            const side = Math.floor(Math.random() * 4); 

            if (side === 0) { 
                startX = Math.random() * (Game.width - enemyWidth);
                startY = -enemyHeight;
            } else if (side === 1) { 
                startX = Game.width;
                startY = Math.random() * (Game.height - enemyHeight);
            } else if (side === 2) { 
                startX = Math.random() * (Game.width - enemyWidth);
                startY = Game.height;
            } else { 
                startX = -enemyWidth;
                startY = Math.random() * (Game.height - enemyHeight);
            }

            const currentHP = getEnemyHP(baseConfig); 
            const scoreValue = getEnemyScore(baseConfig);
            
            let burstCount = 1;
            let shotInterval = 3750; 
            let spreadAngle = 0; 
            let isMovingToCenter = false;
            let dropChance = 0; 

            if (isType2) {
                burstCount = 3; 
                shotInterval = 18250; 
                spreadAngle = 25; 
                isMovingToCenter = true; 
            } else if (isGriefer) {
                shotInterval = 999999; 
                isMovingToCenter = false; 
            } else if (baseConfig.type === 3) {
                burstCount = 5; 
                shotInterval = 18250; 
                spreadAngle = 330; 
                dropChance = 1.0; 
            }

            const enemy = {
                x: startX, 
                y: startY,
                width: enemyWidth,
                height: enemyHeight,
                speed: 0.15 * 0.5, 
                hp: currentHP, 
                baseHp: currentHP, 
                score: scoreValue,
                dropChance: dropChance,
                lastShotTime: 0,
                shotInterval: shotInterval, 
                burstCount: burstCount, 
                spreadAngle: spreadAngle, 
                isMovingToCenter: isMovingToCenter, 
                element: document.createElement('div'),
                type: baseConfig.type 
            };

            enemy.element.className = baseConfig.className;
            enemy.element.innerHTML = Math.ceil(enemy.hp); 
            enemy.element.style.backgroundColor = baseConfig.color;
            enemy.element.style.left = `${enemy.x}px`;
            enemy.element.style.top = `${enemy.y}px`;
            container.appendChild(enemy.element);
            Game.enemies.push(enemy);
        }

        function isEnemyInBounds(enemy) { 
            return (
                enemy.x + enemy.width > 0 &&     
                enemy.x < Game.width &&          
                enemy.y >= 0 &&                  
                enemy.y < Game.height            
            );
        }

        function updateEnemies(timestamp) { 
            if (Game.gameState === 'BOSS_FIGHT' && Game.boss) {
                return;
            }

            Game.enemies = Game.enemies.filter(enemy => {
                const enemyCenter = { x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height / 2 };
                let targetX, targetY;
                if (enemy.isMovingToCenter) {
                    targetX = GAME_CENTER.x;
                    targetY = GAME_CENTER.y;
                } else {
                    const playerCenter = getPlayerCenter();
                    targetX = playerCenter.x;
                    targetY = playerCenter.y;
                }
                const angleToTarget = Math.atan2(targetY - enemyCenter.y, targetX - enemyCenter.x);
                enemy.x += enemy.speed * Math.cos(angleToTarget);
                enemy.y += enemy.speed * Math.sin(angleToTarget);

                enemy.element.style.top = `${enemy.y}px`;
                enemy.element.style.left = `${enemy.x}px`;
                enemy.element.innerHTML = Math.ceil(enemy.hp); 

                if (enemy.hp > 0 && enemy.hp <= enemy.baseHp && enemy.type !== 4) { 
                    if (isEnemyInBounds(enemy)) { 
                        if (enemy.type === 1 || enemy.type === 2 || enemy.hp < enemy.baseHp * 0.5) { 
                            if (timestamp - enemy.lastShotTime > enemy.shotInterval) {
                                if (enemy.type === 2 || enemy.spreadAngle > 0) {
                                    const spreadRadians = enemy.spreadAngle * (Math.PI / 180); 
                                    const totalSpread = enemy.burstCount - 1; 
                                    for (let i = 0; i < enemy.burstCount; i++) {
                                        const spreadOffset = i - totalSpread / 2; 
                                        const angleOffset = spreadOffset * (spreadRadians / (totalSpread > 0 ? totalSpread : 1));
                                        createEnemyBullet(enemy, getPlayerCenter().x, getPlayerCenter().y, angleOffset);
                                    }
                                } else {
                                    createEnemyBullet(enemy, getPlayerCenter().x, getPlayerCenter().y, 0); 
                                }
                                enemy.lastShotTime = timestamp;
                            }
                        }
                    } 
                }
                
                const REMOVE_MARGIN = 100;
                const enemyLeft = enemy.x;
                const enemyRight = enemy.x + enemy.width;
                const enemyTop = enemy.y;
                const enemyBottom = enemy.y + enemy.height;
                
                if (enemyRight < -REMOVE_MARGIN || 
                    enemyLeft > Game.width + REMOVE_MARGIN || 
                    enemyBottom < -REMOVE_MARGIN || 
                    enemyTop > Game.height + REMOVE_MARGIN) {
                    container.removeChild(enemy.element);
                    return false; 
                }
                return true;
            });
        }

        function createEnemyBullet(enemy, targetX, targetY, angleOffset = 0) { 
            const currentSpeed = (enemy.type === 99 || enemy.type === 100) ? BOSS_BULLET_SPEED : ENEMY_BULLET_SPEED;
            const center = {
                x: enemy.x + enemy.width / 2,
                y: enemy.y + enemy.height / 2
            };
            const angle = Math.atan2(targetY - center.y, targetX - center.x) + angleOffset;

            const bullet = {
                x: center.x - 3, 
                y: center.y - 3, 
                width: 6, height: 6, 
                element: document.createElement('div'),
                isTracking: false,
                dx: Math.cos(angle) * currentSpeed, 
                dy: Math.sin(angle) * currentSpeed,
                speed: currentSpeed, 
                type: enemy.type, 
                damage: ENEMY_BULLET_DAMAGE
            };
            
            bullet.element.className = 'enemy-bullet';
            bullet.element.style.backgroundColor = (enemy.type === 1) ? 'red' : (enemy.type === 2) ? 'magenta' : 'yellow';
            bullet.element.style.left = `${bullet.x}px`;
            bullet.element.style.top = `${bullet.y}px`;
            container.appendChild(bullet.element);
            Game.enemyBullets.push(bullet);
        }


	// *** æ–°å¢å‡½å¼ï¼šå…è¨±æ‰‹å‹•æŒ‡å®šè§’åº¦ã€é€Ÿåº¦ã€é¡è‰²çš„å­å½ˆ ***
        function createEnemyBulletManual(startX, startY, angle, speed, color) {
            const bullet = {
                x: startX - 3, 
                y: startY - 3, 
                width: 6, height: 6, 
                element: document.createElement('div'),
                isTracking: false,
                dx: Math.cos(angle) * speed, 
                dy: Math.sin(angle) * speed,
                speed: speed, 
                type: 101, // æ¨™è¨˜ç‚º Boss 3 å­å½ˆ
                damage: ENEMY_BULLET_DAMAGE
            };
            
            bullet.element.className = 'enemy-bullet';
            bullet.element.style.backgroundColor = color;
            bullet.element.style.left = `${bullet.x}px`;
            bullet.element.style.top = `${bullet.y}px`;
            bullet.element.style.boxShadow = `0 0 5px ${color}`; // å¢åŠ ä¸€é»ç™¼å…‰æ„Ÿ
            
            container.appendChild(bullet.element);
            Game.enemyBullets.push(bullet);
        }







        function updateEnemyBullets() { 
            Game.enemyBullets.forEach(bullet => {
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
                bullet.element.style.top = `${bullet.y}px`;
                bullet.element.style.left = `${bullet.x}px`;
            });
        }
        




function playerShoot(timestamp, dt) { 
    const currentWeaponIndex = Game.currentWeaponIndex;
    if (currentWeaponIndex >= 3) return; 

    const hmg = Game.hmgState;
    const weapon = Game.weapons[currentWeaponIndex];
    const center = getPlayerCenter();
    const angleToMouse = Math.atan2(Game.mouse.y - center.y, Game.mouse.x - center.x);
    // âœ¨ é—œéµä¿®æ­£ï¼šç›´æ¥æŠ“å– DOM å…ƒç´ 
    const pElem = document.getElementById('player');

    // --- é‡å°ç¬¬ä¸‰æŠŠæ­¦å™¨ (Index 2) çš„éè¼‰åˆ¤æ–· ---
    if (currentWeaponIndex === 2) {
        // 1. æª¢æŸ¥å†·å»
        if (hmg.isCoolingDown) {
            if (timestamp >= hmg.cooldownEndTime) hmg.isCoolingDown = false;
            else return; // å†·å»ä¸­ä¸åŸ·è¡Œç´¯åŠ èˆ‡å°„æ“Š
        }

        const timeSinceMove = timestamp - hmg.lastMoveTime;
        if (timeSinceMove > HMG_OVERLOAD_TRIGGER_MS) {
            if (!hmg.isOverloading) {
                hmg.isOverloading = true;
                hmg.overloadStartTime = timestamp;
		if (pElem) pElem.classList.add('player-overload');
            }
            
            const overloadDuration = timestamp - hmg.overloadStartTime;

            // --- è§¸ç™¼ 4 ç§’å¤§æ‹› ---
            if (overloadDuration >= HMG_MAX_DURATION) {
                const rampSteps = Math.floor(HMG_MAX_DURATION / HMG_RAMP_INTERVAL);
                const maxMultiplier = 1 + (rampSteps * HMG_RAMP_RATE);
                const currentFireRate = weapon.fireRate / maxMultiplier;
                const bulletCount = Math.floor(HMG_EXPLOSION_BASE_SEC / currentFireRate);

                for (let i = 0; i < bulletCount; i++) {
                    const angle = (Math.PI * 2 / bulletCount) * i;
                    createBullet(center.x - 2, center.y - 2, 'orange', weapon.bulletSpeed, angle, weapon.damage);
                }

                hmg.isCoolingDown = true;
                hmg.cooldownEndTime = timestamp + HMG_COOLDOWN_MS;
                hmg.isOverloading = false;
		if (pElem) pElem.classList.add('player-overload');
                return;
            }
        } else {
            if (hmg.isOverloading) {
                hmg.isOverloading = false;
		if (pElem) pElem.classList.add('player-overload');
            }
        }
    }

    // --- å°„æ“Šç´¯åŠ å™¨è™•ç† ---
    Game.fireAccumulators[currentWeaponIndex] += dt; 

    // è¨ˆç®—ç•¶å‰å¯¦éš›æ”»é€Ÿ (å¦‚æœæ˜¯æ­¦å™¨2ä¸”åœ¨éè¼‰ä¸­ï¼Œå‰‡è®Šå¿«)
    let fireRate = weapon.fireRate;
    if (currentWeaponIndex === 2 && hmg.isOverloading) {
        const overloadDuration = timestamp - hmg.overloadStartTime;
        const rampSteps = Math.floor(overloadDuration / HMG_RAMP_INTERVAL);
        const speedMultiplier = 1 + (rampSteps * HMG_RAMP_RATE);
        fireRate = weapon.fireRate / speedMultiplier;
    }

    let firedCount = 0;
    while (Game.fireAccumulators[currentWeaponIndex] >= fireRate) {
        Game.fireAccumulators[currentWeaponIndex] -= fireRate; 
        firedCount++;

        const bulletsToFire = [];
        let speed = weapon.bulletSpeed;
        const damage = weapon.damage; 
        
        if (currentWeaponIndex === 2 && hmg.isOverloading) {
            // éè¼‰æ¨¡å¼ï¼šæ•£åº¦ç¸®å°è‡³ 5 åº¦
            const spreadRad = HMG_OVERLOAD_SPREAD * (Math.PI / 180);
            const numBullets = 2;
	    speed = weapon.bulletSpeed * 1.2;
            for (let i = 0; i < numBullets; i++) {
            	const randomOffset = (Math.random() * 2 - 1) * spreadRad;
            	bulletsToFire.push({ angle: angleToMouse + randomOffset, damage: damage, color: 'orange' });
	    }

        } else if (weapon.type === "single") {
            bulletsToFire.push({ angle: angleToMouse, damage: damage, color: weapon.color });
        } else if (weapon.type === "random_spread_15") { 
            const numBullets = 15;
            const spreadRadians = 15 * (Math.PI / 180); 
            for (let i = 0; i < numBullets; i++) {
                const randomOffset = (Math.random() * 2 - 1) * spreadRadians; 
                bulletsToFire.push({ angle: angleToMouse + randomOffset, damage: damage, color: weapon.color }); 
            }
        } else if (weapon.type === "random_twin") {
            const numBullets = 2;
            const spreadRadians = 7.5 * (Math.PI / 180); 
            for (let i = 0; i < numBullets; i++) {
                const randomOffset = (Math.random() * 2 - 1) * spreadRadians; 
                bulletsToFire.push({ angle: angleToMouse + randomOffset, damage: damage, color: weapon.color }); 
            }
        } 

        bulletsToFire.forEach(config => {
            createBullet(center.x - 2, center.y - 2, config.color, speed, config.angle, config.damage);
        });
        
        if (firedCount > 50) break; 
    }
    
    if (Game.fireAccumulators[currentWeaponIndex] > fireRate * 1.5) {
         Game.fireAccumulators[currentWeaponIndex] = fireRate * 0.99;
    }
}






        
        function createBullet(x, y, color, speed, angle, damage) { 
            const dx = speed * Math.cos(angle);
            const dy = speed * Math.sin(angle);

            const bullet = {
                x: x, y: y, width: 4, height: 4, dx: dx, dy: dy, 
                element: document.createElement('div'),
                damage: damage 
            };

            bullet.element.className = 'bullet';
            bullet.element.style.backgroundColor = color;
            bullet.element.style.left = `${bullet.x}px`;
            bullet.element.style.top = `${bullet.y}px`;
            container.appendChild(bullet.element);
            Game.bullets.push(bullet);
        }

        function updateBullets() { 
            Game.bullets.forEach(bullet => {
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
                
                bullet.element.style.top = `${bullet.y}px`;
                bullet.element.style.left = `${bullet.x}px`;
            });
        }
        
        function createHeartDrop(x, y) { 
             const drop = {
                x: x, y: y, width: 15, height: 15, dy: 0, 
                value: 10, element: document.createElement('div')
            };
            drop.element.className = 'heart-drop';
            drop.element.innerHTML = 'H';
            drop.element.style.left = `${drop.x}px`;
            drop.element.style.top = `${drop.y}px`;
            container.appendChild(drop.element);
            Game.drops.push(drop);
        }

        function updateDrops() { }
        
        function checkCollisions(timestamp) { 
            const hitBullets = [];
            const hitEnemies = [];
            const hitEnemyBullets = [];
            const collectedDrops = [];
            
            const isTotallyInvulnerable = Game.isInvincible || (timestamp - Game.lastPlayerHitTime < PLAYER_HIT_COOLDOWN);
            
            if (isTotallyInvulnerable) {
                player.classList.add('player-hit');
                player.classList.remove('player-dash-ready');
            } else {
                player.classList.remove('player-hit');
            }

            // 1. ç©å®¶å­å½ˆ vs æ•µè»
            Game.bullets.forEach((bullet, bIndex) => {
                const damage = bullet.damage || 1.0; 
                Game.enemies.forEach((enemy, eIndex) => {
                    if (isColliding(bullet, enemy)) {
                        if (!hitBullets.includes(bIndex)) hitBullets.push(bIndex);
                        enemyHitEffect(enemy);
                        enemy.hp -= damage; 
                        enemy.element.innerHTML = Math.ceil(enemy.hp);
                        recordDamage(damage); 

                        if (enemy.hp <= 0 && enemy.type < 99) {
                            if (!hitEnemies.includes(eIndex)) {
                                hitEnemies.push(eIndex);
                                updateScore(enemy.score); 
                                if (enemy.dropChance > 0 && Math.random() < enemy.dropChance) {
                                    createHeartDrop(enemy.x + enemy.width / 2 - 7, enemy.y + enemy.height / 2 - 7);
                                }
                            }
                        }
                    }
                });
            });

            // 2. ç©å®¶ vs æ•µè»å­å½ˆ / 3. ç©å®¶ vs æ•µè»
            if (Game.player.hp > 0 && !isTotallyInvulnerable) { 
                let playerWasHit = false;

                Game.enemyBullets.forEach((eBullet, ebIndex) => {
                    if (isColliding(eBullet, Game.player)) {
                         if (!hitEnemyBullets.includes(ebIndex)) {
                            hitEnemyBullets.push(ebIndex);
                            Game.player.hp -= ENEMY_BULLET_DAMAGE; 
                            playerWasHit = true;
                        }
                    }
                });

                Game.enemies.forEach((enemy, eIndex) => {
                    if (isColliding(enemy, Game.player)) {
                        Game.player.hp -= ENEMY_BULLET_DAMAGE; 
                        playerWasHit = true;
                         if (enemy.hp <= 0 && enemy.type < 99) { 
                            if (!hitEnemies.includes(eIndex)) {
                                hitEnemies.push(eIndex);
                                updateScore(enemy.score); 
                            }
                        }
                    }
                });
                
                if (playerWasHit) {
                    Game.lastPlayerHitTime = timestamp; 
                    updateHPDisplay(); 
                    if (Game.player.hp <= 0) gameOver(); 
                }
            } else if (Game.player.hp > 0 && isTotallyInvulnerable) { 
                Game.enemyBullets.forEach((eBullet, ebIndex) => {
                    if (isColliding(eBullet, Game.player)) {
                         if (!hitEnemyBullets.includes(ebIndex)) hitEnemyBullets.push(ebIndex);
                    }
                });
                 Game.enemies.forEach((enemy, eIndex) => {
                    if (isColliding(enemy, Game.player)) {
                        if (enemy.hp <= 0 && enemy.type < 99) {
                             if (!hitEnemies.includes(eIndex)) {
                                hitEnemies.push(eIndex);
                                updateScore(enemy.score); 
                            }
                        }
                    }
                });
            }

            // 4. ç©å®¶ vs æ‰è½ç‰© 
            Game.drops.forEach((drop, dIndex) => {
                if (isColliding(drop, Game.player)) {
                    if (!collectedDrops.includes(dIndex)) {
                        collectedDrops.push(dIndex);
                        Game.player.hp = Math.min(MAX_PLAYER_HP, Game.player.hp + drop.value);
                        updateHPDisplay();
                    }
                }
            });

            cleanupHits(Game.bullets, hitBullets);
            cleanupHits(Game.enemies, hitEnemies); 
            cleanupHits(Game.enemyBullets, hitEnemyBullets);
            cleanupHits(Game.drops, collectedDrops);
        }
        
        function isColliding(rect1, rect2) { 
            const overlapX = rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x;
            const overlapY = rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
            return overlapX && overlapY;
        }

        function cleanupHits(array, indices) { 
            indices.sort((a, b) => b - a).forEach(index => {
                if(array[index] && array[index].element) {
                     if ((array[index].type === 99 || array[index].type === 100) && array[index].hp <= 0) {
                        return;
                    }
                    container.removeChild(array[index].element);
                    array.splice(index, 1);
                }
            });
        }

        function cleanupObjects() { 
            const removeBullet = (bullet) => {
                const margin = 50; 
                return bullet.y < -margin || bullet.y > Game.height + margin || bullet.x > Game.width + margin || bullet.x < -margin;
            };
            Game.bullets = Game.bullets.filter(bullet => {
                if (removeBullet(bullet)) { container.removeChild(bullet.element); return false; }
                return true;
            });
            Game.enemyBullets = Game.enemyBullets.filter(bullet => {
                if (removeBullet(bullet)) { container.removeChild(bullet.element); return false; }
                return true;
            });
            Game.drops = Game.drops.filter(drop => {
                if (drop.y > Game.height) { container.removeChild(drop.element); return false; }
                return true;
            });
        }
        
        // --- éµç›¤å’Œæ»‘é¼ è™•ç† ---
        const keys = {};
        const directionalKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'];

        document.addEventListener('keydown', (e) => {
            if (directionalKeys.includes(e.key) || e.key === ' ' || e.key === 'e' || e.key === 'E' || e.key === 'i' || e.key === 'I' || e.key === 'u' || e.key === 'U' || e.key === 'Escape') {
                e.preventDefault();
                if (!Game.isGameActive && directionalKeys.includes(e.key)) {
                    Game.isGameActive = true;
                    startMessageElement.style.display = 'none'; 
                    Game.lastFrameTime = performance.now(); 
                }
            }
            
            if (e.key === 'Escape' && Game.isGameActive && !Game.isRunning) return; 

            if (e.key === 'Escape' && Game.isGameActive) {
                Game.isPaused = !Game.isPaused;
                if (Game.isPaused) {
                    pauseMessageElement.style.display = 'block';
                } else {
                    pauseMessageElement.style.display = 'none';
                    Game.lastFrameTime = performance.now(); 
                }
            }
            
            if (!Game.isPaused) {
                 if (e.key === 'e' || e.key === 'E') {
                    if (!isWeaponKeyHeld && Game.isGameActive) {
                        toggleWeapon();
                        isWeaponKeyHeld = true; 
                    }
                }
                if (e.key === 'i' || e.key === 'I') {
                    Game.isInvincible = !Game.isInvincible;
                    if (Game.isInvincible) {
                        player.style.backgroundColor = 'yellow'; player.style.boxShadow = '0 0 15px white';
                    } else { resetPlayerColor(); }
                }
                if (e.key === 'u' || e.key === 'U') {
                    if (Game.isGameActive) updateScore(10000); 
                }
            }
            keys[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            if (e.key === 'e' || e.key === 'E') isWeaponKeyHeld = false;
        });
        
        container.addEventListener('mousemove', (e) => {
            const rect = container.getBoundingClientRect();
            Game.mouse.x = e.clientX - rect.left;
            Game.mouse.y = e.clientY - rect.top;
        });


	container.addEventListener('wheel', (e) => {
            if (Game.isPaused || !Game.isGameActive) return;
            e.preventDefault();
            if (e.deltaY > 0) {
                toggleWeapon(1); // ä¸‹ä¸€å€‹
            } else {
                toggleWeapon(-1); // ä¸Šä¸€å€‹
            }
        });


        function handleInput(timestamp) {
            if (!Game.isGameActive || Game.isPaused) return; 

            const p = Game.player;
            const s = p.speed;
            const maxY = PLAYER_MAX_Y_BOUND; 
	    
	    let isMoving = false;

            if (keys['ArrowLeft'] || keys['a']) { p.x = Math.max(0, p.x - s); isMoving = true;}
            if (keys['ArrowRight'] || keys['d']) { p.x = Math.min(Game.width - p.width, p.x + s); isMoving = true;}
            if (keys['ArrowUp'] || keys['w']) { p.y = Math.max(0, p.y - s); isMoving = true;}
            if (keys['ArrowDown'] || keys['s']) { p.y = Math.min(maxY - p.height, p.y + s); isMoving = true;} 
	    Game.isPlayerMoving = isMoving;


	    if (isMoving) {
        	Game.hmgState.lastMoveTime = timestamp; 
        	if (Game.hmgState.isOverloading) {
            	    Game.hmgState.isOverloading = false;
		    // âœ… ä¿®æ­£ï¼šç›´æ¥ä½¿ç”¨ player æˆ–æ˜¯ document.getElementById('player')
            	    const playerElem = document.getElementById('player');
            	    if (playerElem) {
                	playerElem.classList.remove('player-overload');
            	    }
        	}
    	    }




            if (keys[' ']) performDash(timestamp);
            updatePlayerPosition();
        }

        function toggleWeapon(direction = 1) {
	    // è¨ˆç®—æ–°çš„ index
            if (direction === 1) {
                Game.currentWeaponIndex = (Game.currentWeaponIndex + 1) % Game.weapons.length;
            } else {
                Game.currentWeaponIndex = (Game.currentWeaponIndex - 1 + Game.weapons.length) % Game.weapons.length;
            }

	    // --- ç¢ºä¿æ‰€æœ‰é›·å°„ç›¸é—œçš„ class éƒ½è¢«ç§»é™¤ (æ›æ­¦å™¨æ™‚çš„é—œéµæ¸…ç†) ---
    	    player.classList.remove('player-charging');
    	    player.classList.remove('laser-charging-alt');
    	    // å¦‚æœæ‚¨ç¨‹å¼ç¢¼ä¸­é‚„æœ‰ laser-charging-alt2ï¼Œä¹Ÿæ‡‰åœ¨æ­¤ç§»é™¤
    	    player.classList.remove('laser-charging-alt2'); 
    	    Game.kineticChargeTime = 0; 
    	    Game.timeStopped = 0; // é‡ç½®éœæ­¢è¨ˆæ™‚å™¨

            staticFieldAura.style.display = 'none';
            continuousSwordBlade.style.display = 'none';
            if (!Game.isInvincible) resetPlayerColor();
            if (Game.currentWeaponIndex === STATIC_FIELD_WEAPON_INDEX) {
                staticFieldAura.style.display = 'block';
                staticFieldAura.classList.remove('static-field-pulse');
            } else if (Game.currentWeaponIndex === SWORD_BLADE_WEAPON_INDEX) {
                const center = getPlayerCenter();
                Game.currentSwordAngle = Math.atan2(Game.mouse.y - center.y, Game.mouse.x - center.x);
            }	
            else if (Game.hmgState) {
                Game.hmgState.isOverloading = false;
                Game.hmgState.isCoolingDown = false; 
                // é€™æ¨£æ›å›ä¾†çš„æ™‚å€™æœƒé‡æ–°è¨ˆç®— 0.5 ç§’
                Game.hmgState.lastMoveTime = performance.now(); 
            }
            const playerElem = document.getElementById('player');
            if (playerElem) playerElem.classList.remove('player-overload');



            updateWeaponStatusDisplay();
        }

        function initializeGame() {
            updateWeaponStats(); 
            updatePlayerPosition(); 
            updateHPDisplay(); 
            container.focus(); 
            staticFieldAura.style.display = 'none';
            continuousSwordBlade.style.display = 'none'; 
            
            const center = getPlayerCenter();
            Game.currentSwordAngle = Math.atan2(Game.mouse.y - center.y, Game.mouse.x - center.x);
            
            updateWeaponStatusDisplay();
            updateDPS(performance.now()); 
            
            Game.lastFrameTime = 0;
            requestAnimationFrame(gameLoop);
        }

        window.onload = initializeGame;
    </script>
</body>
</html>
