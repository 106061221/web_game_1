<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>雙搖桿射擊遊戲 - 更新版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: Arial; touch-action: none; }
        canvas { display: block; background: #000; border: 5px solid #333; box-sizing: border-box; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <div>武器編號: <span id="weapon-id">1</span></div>
        <div style="margin-top:5px; font-size: 12px; color: #aaa;">左邊點擊換槍 | 瞬移已移除</div>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const weaponText = document.getElementById('weapon-id');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// 遊戲狀態
const player = { x: canvas.width/2, y: canvas.height/2, size: 20, speed: 5, color: '#00ccff' };
const crosshair = { x: canvas.width/2, y: canvas.height/2, size: 10, color: '#ff0000' };
let bullets = [];
let weaponIndex = 0; 
const deadzone = 10; // 搖桿死區：位移小於 10 像素不移動

// 搖桿控制
let leftJoystick = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };
let rightJoystick = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };

canvas.addEventListener('touchstart', (e) => {
    for (let touch of e.changedTouches) {
        if (touch.clientX < canvas.width / 2) {
            leftJoystick.active = true;
            leftJoystick.startX = leftJoystick.currX = touch.clientX;
            leftJoystick.startY = leftJoystick.currY = touch.clientY;
            switchWeapon();
        } else {
            rightJoystick.active = true;
            rightJoystick.startX = rightJoystick.currX = touch.clientX;
            rightJoystick.startY = rightJoystick.currY = touch.clientY;
            // 移除瞬移呼叫
        }
    }
});

canvas.addEventListener('touchmove', (e) => {
    for (let touch of e.changedTouches) {
        if (leftJoystick.active && touch.clientX < canvas.width/2) {
            leftJoystick.currX = touch.clientX;
            leftJoystick.currY = touch.clientY;
        }
        if (rightJoystick.active && touch.clientX >= canvas.width/2) {
            rightJoystick.currX = touch.clientX;
            rightJoystick.currY = touch.clientY;
        }
    }
});

canvas.addEventListener('touchend', (e) => {
    for (let touch of e.changedTouches) {
        if (touch.clientX < canvas.width/2) leftJoystick.active = false;
        else rightJoystick.active = false;
    }
});

function switchWeapon() {
    weaponIndex = (weaponIndex + 1) % 3;
    weaponText.innerText = weaponIndex + 1;
}

function fire() {
    const dx = crosshair.x - player.x;
    const dy = crosshair.y - player.y;
    const angle = Math.atan2(dy, dx);

    if (weaponIndex === 0) {
        createBullet(angle);
    } else if (weaponIndex === 1) {
        createBullet(angle - 0.2);
        createBullet(angle);
        createBullet(angle + 0.2);
    } else if (weaponIndex === 2) {
        createBullet(angle, 10);
        createBullet(angle, -10);
    }
}

function createBullet(angle, offset = 0) {
    bullets.push({
        x: player.x + Math.cos(angle + Math.PI/2) * offset,
        y: player.y + Math.sin(angle + Math.PI/2) * offset,
        vx: Math.cos(angle) * 10,
        vy: Math.sin(angle) * 10
    });
}

let frameCount = 0;
function update() {
    // 1. 移動玩家 (左搖桿 + 死區邏輯)
    if (leftJoystick.active) {
        const dx = leftJoystick.currX - leftJoystick.startX;
        const dy = leftJoystick.currY - leftJoystick.startY;
        const dist = Math.hypot(dx, dy);
        
        // 只有當位移超過 deadzone 時才移動
        if (dist > deadzone) {
            player.x += (dx / dist) * player.speed;
            player.y += (dy / dist) * player.speed;
        }
    }

    // 2. 移動準星 (右搖桿)
    if (rightJoystick.active) {
        const dx = rightJoystick.currX - rightJoystick.startX;
        const dy = rightJoystick.currY - rightJoystick.startY;
        const dist = Math.hypot(dx, dy);
        if (dist > 5) {
            crosshair.x = player.x + (dx / dist) * 150;
            crosshair.y = player.y + (dy / dist) * 150;
            if (frameCount % 8 === 0) fire(); 
        }
    } else {
        crosshair.x = player.x;
        crosshair.y = player.y;
    }

    // 邊界限制
    player.x = Math.max(20, Math.min(canvas.width - 20, player.x));
    player.y = Math.max(20, Math.min(canvas.height - 20, player.y));

    // 更新子彈
    bullets.forEach((b, i) => {
        b.x += b.vx; b.y += b.vy;
        if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) bullets.splice(i, 1);
    });

    frameCount++;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 畫準星
    if (rightJoystick.active) {
        ctx.strokeStyle = crosshair.color;
        ctx.beginPath();
        ctx.arc(crosshair.x, crosshair.y, 10, 0, Math.PI*2);
        ctx.stroke();
    }

    // 畫玩家
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x - 15, player.y - 15, 30, 30);

    // 畫子彈
    ctx.fillStyle = '#fff700';
    bullets.forEach(b => ctx.fillRect(b.x - 3, b.y - 3, 6, 6));

    // 畫搖桿視覺
    if (leftJoystick.active) drawJoystick(leftJoystick, "#00ccff");
    if (rightJoystick.active) drawJoystick(rightJoystick, "#ff0000");

    update();
    requestAnimationFrame(draw);
}

function drawJoystick(joy, color) {
    ctx.beginPath();
    ctx.arc(joy.startX, joy.startY, 40, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(joy.currX, joy.currY, 20, 0, Math.PI*2);
    ctx.fillStyle = color + "66"; // 加上透明度
    ctx.fill();
}

draw();
</script>
</body>
</html>
